#!/bin/sh

### BEGIN INIT INFO
# Provides:          live-init
# Required-Start:    checkroot checkroot-bootclean
# Required-Stop:
# Should-Start:
# Should-Stop:
# Default-Start:     S
# Default-Stop:
# Short-Description: live-init
# Description: localize /etc/skel, create /home/demo, customize X, mirrors, set default desktop
### END INIT INFO

XSESSION_DIR=/usr/share/xsessions

 ICON_MANAGERS="rox space"
  rox_DESKTOPS=fluxbox,icewm,jwm
space_DESKTOPS=fluxbox,icewm,jwm
      MENU_WMs="fluxbox icewm jwm"
      FF_PREFS="/etc/skel/.mozilla/firefox/*/prefs.js"
      INIT_OUT=/live/config/init.out
AUTOMOUNT=
#-jbb For debugging
CMDLINE=${CMDLINE:-$(cat /proc/cmdline)}
for param in $CMDLINE; do
    case "$param" in
             desktop=*)  CMD_DESKTOP=${param#*=}                    ;;
                 dpi=*)      CMD_DPI=${param#*=}                    ;;
                 kbd=*)      CMD_KBD=${param#*=} ;     DO_XKBD=true ;;
               kbopt=*)   XKBOPTIONS=${param#*=} ;     DO_XKBD=true ;;
               kbvar=*)   XKBVARIANT=${param#*=} ;     DO_XKBD=true ;;
                lang=*)     CMD_LANG=${param#*=} ;     DO_XKBD=true ;;
              mirror=*)   CMD_MIRROR=${param#*=}                    ;;

              xorgconf)                              MAKE_XORG=true ;;
                xres=*)                              MAKE_XORG=true ;;
                drvr=*)                              MAKE_XORG=true ;;
               xdrvr=*)                              MAKE_XORG=true ;;

automount=off|amnt=off)                          AUTOMOUNT_OFF=true ;;
        automount|amnt)                              AUTOMOUNT=true ;;
    automount=*|amnt=*)    CMD_MOUNT=${param#*=} ;   AUTOMOUNT=true ;;
               mount=*)    CMD_MOUNT=${param#*=}                    ;;
               fstab=*)    CMD_FSTAB=${param#*=}                    ;;

    esac
done

PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin"; export PATH

umask 022

. /usr/share/antiX/lib/live-init-utils.sh

start_init_logging
load_translation

main() {
    case "$1" in
        start)
            do_start
            ;;
        stop)
            save_desktop
            exit 0
            ;;
        test)
            restore_desktop
            exit 0
            ;;
        *)
            echo "Usage: $0 {start|stop}"
            exit 1
            ;;
    esac
}

get_init_param() { eval $(grep ^$1= $INIT_OUT) ;}

save_desktop() {
    get_init_param REMASTERABLE
    [ "$REMASTERABLE" ] || return

    get_init_param DID_TORAM
    if [ "$DID_TORAM" ]; then

        get_init_param BOOT_UUID
        if [ -z "$BOOT_UUID" ; then
            echo "Could not find UUID of boot device for remounting"
            echo "Will not save defaults desktops"
            return
        fi
        mkdir -p /live/boot-dev/
        if ! mount -U $BOOT_UUID /live/boot-dev; then
            echo "Could not remount boot device"
            echo "Will not save defaults desktops"
            return
        fi
    fi

    get_init_param SQFILE_PATH
    local to_dir=/live/boot-dev/$SQFILE_PATH/desktop

    local user from to
    for user in $(ls /home); do
        from="/home/$user/.desktop-session/default-desktop"
        [ -e "$from" ] || continue
        to="$to_dir/$user/default-desktop"
        echo "maybe save $user desktop"
        should_copy "$from" "$to" || continue
        mkdir -p $(dirname "$to")
        cp "$from" "$to"
        echo "save $user desktop"
    done
}

should_copy() {
    local from="$1"  to="$2"
    [ -e "$from" ] || return 1
    [ -e "$to"   ] || return 0
    diff -q "$from" "$to" 1>/dev/null 2>/dev/null && return 1
    return 0
}

restore_desktop() {
    # There are many reasons to not restore
    [ "$CMD_DESKTOP" ] && return

    get_init_param REMASTERABLE
    [ "$REMASTERABLE" ] || return

    get_init_param PERSISTENCE
    [ "$PERSISTENCE" ] && return

    get_init_param SQFILE_PATH

    local d dir
    for d in /live/boot-dev live/to-ram; do
        d=$d/$SQFILE_PATH/desktop
        [ -d $d ] || continue
        dir=$d
        break
    done

    [ "$dir" ] || return

    local user dest_dir dest sorc
    for user in $(ls $dir); do
        sorc=$dir/$user/default-desktop
        dest_dir=/home/$user/.desktop-session
        [ -d "$dest_dir" ] || continue
        [ -e "$sorc"     ] || continue
        local dest=$dest_dir/default-desktop
        echo "maybe restore $user desktop"
        should_copy $sorc $dest || continue
        echo "restore $user desktop"
        cp "$sorc" "$dest"
        chown $user:users $dest
    done
}

create_home() {

    local demo=/home/demo
    rmdir $demo 2>/dev/null

    if test -d /home && ls /home | grep -v lost+found | grep -q [a-zA-Z0-9]; then
        echo_live "Files already exist under %s" $(pquote /home)
        echo_live "Not creating or populating %s" $(pquote $demo)
        return
    fi

    echo_live "Populating %s directory" $(pquote $demo)

    mkdir -p $demo
    cp -r -P -p mode /etc/skel/* /etc/skel/.[a-zA-Z]* $demo 2>/dev/null
    chown -R demo:users $demo 2>/dev/null
}

localize_skel() {
    local l10n_dir=/usr/share/antiX/localisation
    local from=$l10n_dir/$1
    local dest=/etc/skel

    # Silently skip systems which have no localisation directory
    [ -d "$l10n_dir" ] || return

    if ! [ -d $from ]; then
        error "Unknown menu localization language %s" $(pquote $1)
        error "Directory not found %s" $from
        return
    fi

    echo_live "Localizing menus to %s in %s" $(pquote $1) $(pquote $dest)

    # Basically a cp -a but make all top level files and directories hidden
    for file in $(ls $from); do
       if [ -d $from/$file ]; then
           mkdir -p /$dest/.$file
           cp -a $from/$file/* $dest/.$file
       else
           rm -rf $dest/.$file
           cp $from/$file $dest/.$file
       fi
    done
}

localize_firefox() {
    local pref_files file lang=$1
    local string="user_pref(\"spellchecker.dictionary\","

    pref_files=$(ls $FF_PREFS 2>/dev/null)
    [ "$pref_files" ] || return
    sed -i "/$string/d" $pref_files
    for file in $pref_files; do
        echo "$string \"$lang\");" >> $file
    done
}

set_dpi() {
    local dpi=$1

    if ! echo $dpi | grep -q "^[[:digit:]]\+$"; then
        error "Invalid %s boot parameter %s" $(pquote dpi) $(pquote $dpi)
        return
    fi

    local file
    for file in /etc/slim.conf /usr/share/slim/themes/antiX/slim-install.conf; do
        [ -e $file ] || continue
        echo_live 'In file: %s' $(pquote $file)
        echo_live "Setting %s to %s" $(pquote dpi) $(pquote $dpi)
        sed -i -e "s/^xserver_arguments.*/xserver_arguments -dpi $dpi -nolisten tcp/" $file
    done

    for file in /etc/lightdm/lightdm.conf; do
        [ -e $file ] || continue
        echo_live "In file: %s" $(pquote $file)
        echo_live "Setting %s to %s" $(pquote dpi) $(pquote $dpi)
        sed -i -r "s/^#?\s*(xserver-command=X).*/\1 -dpi $dpi/" $file
    done
}

set_mirror() {
    local mirror=$1

    case "$mirror" in
        [a-zA-Z][a-zA-Z]) ;;
        *)
            error "Bad mirror code %s (expected two letters)" $(pquote $mirror)
            return;;
    esac

    source_list=/etc/apt/sources.list.d/debian.list

    first_write $source_list || [ "$CMD_MIRROR" ] || return

    echo_live "Localizing %s to %s mirror" $(pquote $source_list) $(pquote $MIRROR)
    sed -i "s=/ftp\.\(..\.\)\\?debian\.org/=/ftp.$mirror.debian.org/=" $source_list
}

all_valid_desktops() {
    local raw=$(echo $1 | sed 's/,/ /g')
    echo "    $raw"
    local icon desk
    for icon in $ICON_MANAGERS; do
        echo -n "   "
        for desk in $raw; do
            eval local valid=\$${icon}_DESKTOPS
            #echo "valid: $valid"
            case ",$valid," in
                *,$desk,*) echo -n " $icon-$desk" ;;
            esac
        done
        echo
    done
}

# Returns values in DESKTOP and RAW_DESKTOP
check_icon_manager() {
    local icon=$1 desktop=$2

    [ -z "$desktop" ]            && return 1
    [ -z "${desktop##$icon-*}" ] || return 1

    RAW_DESKTOP=${desktop#$icon-}
    eval local valid=\$${icon}_DESKTOPS
    #echo "valid: $valid"
    case ",$valid," in
        *,$RAW_DESKTOP,*) ;;
        *)
            error "Desktop %s is not %s-enabled" $(pquote $RAW_DESKTOP) $icon
            DESKTOP=$RAW_DESKTOP ;;
    esac
    return 0
}

set_default_desktop() {
    local desktop=$(echo $1 | tr "[A-Z]" "[a-z]")

    local xinitrc=/etc/skel/.xinitrc
    local default
    # Grab default desktop
    default=$(sed -nr "s/^\s*DEFAULT_DESKTOP=\"?'?(.*)/\1/p" $xinitrc | tail -n 1)
    default=${default%\"}
    default=${default%\'}

    if [ -z "$default" ]; then
        error "Could not find %s in %s" $(pquote DEFAULT_DESKTOP) $(pquote $xinitrc)
        return
    fi
    echo_live "Found default desktop %s" $(pquote $default)

    if [ "$desktop" = "$default" ]; then
        echo_live "Desktop %s is already the default" $(pquote $desktop)
        return
    fi

    # Check for valid icon-manager <icon>- prefix
    local DESKTOP RAW_DESKTOP
    for icon in $ICON_MANAGERS; do
        check_icon_manager "$icon" "$desktop" && break
    done

    desktop=${DESKTOP:-$desktop}
    local raw_desktop=${RAW_DESKTOP:-$desktop}

    local valid_desktops
    for x in $(grep -h ^Name= $XSESSION_DIR/* | cut -d= -f2 | tr "[A-Z]" "[a-z]" | sort -u); do
        valid_desktops="$valid_desktops,$x"
    done

    valid_desktops=${valid_desktops#,}
    case ",$valid_desktops," in
        *,$raw_desktop,*) ;;
                   *)
            error "Desktop %s is not a valid desktop." $(pquote $raw_desktop)
            error "Valid choices are %s" "$NO_COLOR$"
            all_valid_desktops $valid
            return;;
    esac

    # Now change the default in the .xinitrc files
    echo_live "Setting default desktop to %s" $(pquote $desktop)

    local default_file=/etc/skel/.desktop-session/default-desktop
    echo $desktop > $default_file

    local regex="s/^DEFAULT_DESKTOP=.*/DEFAULT_DESKTOP=\"$desktop\"/"
    sed -i $regex $xinitrc

    local demo_xinitrc=/home/demo/.xinitrc
    if [ -e $demo_xinitrc ]; then
        sed -i $regex $demo_xinitrc
        chown demo:users $demo_xinitrc
    fi
}

add_fstab_swap() {
    echo_live 'Possibly adding swap partitions to fstab'
    make-fstab --swap-only
}

automount_and_fstab() {

   local        am_file=/etc/fstab.automount
   local     mount_file=/etc/fstab.mount
   local        hp_file=/etc/fstab.hotplug
   local  hp_state_file=$hp_file.state

    # "off" means "off"
    if [ "$CMD_MOUNT" = 'off' -o -n "$AUTOMOUNT_OFF" ]; then
        echo_live "Turning all boot mount options off"
        rm -f $mount_file
        CMD_MOUNT=

        if [ -n "$AUTOMOUNT_OFF" ]; then
            echo_live "Turning automount off"
            AUTOMOUNT=
            rm -f $am_file
        fi
    fi

    # Read in previous value (persistent systems only)
    if [ -z "$CMD_MOUNT" -a -e $mount_file ]; then
        CMD_MOUNT=$(cat $mount_file)
    else
        [ "$CMD_MOUNT" ] && echo $CMD_MOUNT > $mount_file
    fi

    # Mount partitions while building fstab file
    local fstab_opt=
    case ",$CMD_MOUNT" in
        ,all|,usb)
            fstab_opt="$fstab_opt --mount=$CMD_MOUNT" ;;
        ,)
            ;;
        *)
            error "Invalid %s option %s" 'mount/automount' $(pquote $CMD_MOUNT)
    esac

    #echo_live "Building %s via %s" "$(pquote /etc/fstab)" "$(pquote "make-fstab $fstab_opt")"
    grep -q -e ^/dev -e ^UUID= -e ^LABEL=  /etc/fstab || rm /etc/fstab
    make-fstab $fstab_opt

    [ "$AUTOMOUNT" ] && touch $am_file

    if [ -e $am_file ]; then
        echo_live "Automount enabled"
    else
        echo_live "Automount disabled"
    fi

    # The hp_file is removed by /init
    # The hp_state_file carries over "off" setting on persistent systems
    [ -z "$CMD_FSTAB" -a -e $hp_state_file ] && CMD_FSTAB=$(cat $hp_state_file)

    case ",$CMD_FSTAB" in
        ,off)
            echo_live "Disabling fstab hotplugging (this will also disable automount)"
            echo $CMD_FSTAB > $hp_state_file
            rm -f $hp_file  ;;

        ,on|,)
            echo_live "Enabling fstab hotplugging"
            rm -f $hp_state_file
            touch $hp_file;;

        *)
            error "Bad fstab option %s" $(pquote $CMD_FSTAB)
            echo_live "Enabling fstab hotplugging"
            touch $hp_file;;
    esac
}

#----- Main code starts here --------------------------------------------------

do_start() {
    echo_script "Localizing/configuring X-Windows" $0

    DISTRO="unknown"
    for live_config in /live/config/init.out /live/config/linuxrc.out; do
        [ -r "$live_config" ] || continue
        eval $(grep ^DISTRO= $live_config)
        break
    done

    case $DISTRO in
        antiX) automount_and_fstab;;
      MX|MX-*) add_fstab_swap     ;;
            *) error 'Unknown_distro %s' "$(pquote $DISTRO)"
    esac

    #-jbb: for debugging
    unset COUNTRY WM_LANG KEYBOARDS KEYTABLE LANG MIRROR TZ XKBLAYOUT CONSOLE_FONT
    [ "$CMD_LANG" ] && get_init_lang $CMD_LANG error

    usb_rules=/etc/udev/rules.d/99-usbstorage.rules
    usb_unused=$usb_rules.unused


    MIRROR=${CMD_MIRROR:-$MIRROR}
    [ "$MIRROR" ] && set_mirror $MIRROR

    [ "$WM_LANG" ] && localize_skel $WM_LANG

    # Always create keyboard file in non-perisistent system even with no X
    kb_file=/etc/default/keyboard
    default_xkb_opts="grp:alt_shift_toggle,terminate:ctrl_alt_bksp,grp_led:scroll"

    if first_write $kb_file || [ "$DO_XKBD" ]; then
        XKBLAYOUT=${CMD_KBD:-$XKBLAYOUT}
        [ "$XKBLAYOUT"  ] && echo_live "Setting %s to %s" $(pquote xkb-layout)  $(pquote $XKBLAYOUT)
        [ "$XKBMODEL"   ] && echo_live "Setting %s to %s" $(pquote xkb-model)   $(pquote $XKBMODEL)
        [ "$XKBVARIANT" ] && echo_live "Setting %s to %s" $(pquote xkb-variant) $(pquote $XKBVARIANT)
        [ "$XKBOPTIONS" ] && echo_live "Setting %s to %s" $(pquote xkb-options) $(pquote $XKBOPTIONS)

        cat > $kb_file <<Keyboard_Out
XKBMODEL="${XKBMODEL:=pc105}"
XKBLAYOUT="${XKBLAYOUT:=us}"
XKBVARIANT="${XKBVARIANT}"
XKBOPTIONS="${XKBOPTIONS:=$default_xkb_opts}"
Keyboard_Out
    fi

    # Don't bother with X stuff on systems without X
    #--------------------------------------------------------------------------
    if [ ! -d "$XSESSION_DIR" ]; then
        create_home
        exit 0
    fi
    #--------------------------------------------------------------------------

    [ "$CMD_DPI" ] && set_dpi $CMD_DPI

    [ "$CMD_DESKTOP" ] && set_default_desktop $CMD_DESKTOP

    xorg_conf=/etc/X11/xorg.conf


    if [ "$MAKE_XORG" ]; then
        echo_live "Configuring %s file" $(pquote $xorg_conf)
        [ -f "$xorg_conf" ] && mv -f $xorg_conf $xorg_conf.bak
        /usr/sbin/buildxconfig $xorg_conf
        sed -i "s/XkbLayout.*/XkbLayout \"$XKBLAYOUT\"/g" $xorg_conf
    fi

    create_home
    restore_desktop

    enable_xkb="s/^#\?setxkbmap.*/setxkbmap -layout \"$XKBLAYOUT\" -option \"$XKBOPTIONS\" -variant \"$XKBVARIANT\"/"

    for wm in $MENU_WMs;  do
        f1=/home/demo/.$wm/startup
        f2=/etc/skel/.$wm/menu
        f3=/etc/skel/.config/rox.sourceforge.net/ROX-Filer/pb_antiX-$wm
        f4=/etc/skel/.$wm/startup
        [ -e $f1 ] && sed -i -e "$enable_xkb"             $f1
        [ -e $f2 ] && sed -i -e "/gksu antixsources.sh/d" $f2
        [ -e $f3 ] && sed -i -e "/antixsources.desktop/d" $f3
        [ -e $f4 ] && sed -i -e "/toram-eject/d"          $f4
        [ -e $f4 ] && sed -i -e "/persist-config/d"       $f4
        rm -f /etc/skel/Desktop/Install.desktop
    done

} 

main "$@" 2>&1 | tee -a $INIT_LOG_FILE

exit 0
