#!/bin/sh

#==============================================================================
# LiveCD/USB/HD init script
# (C) 2009-2014 BitJam for antiX <antiX@operamail.com>
# Inspired by the work of  Klaus Knopper
#
# License: GPLv3 or later
#==============================================================================

# SUFFIX NOTE: _MP     absolute mountpoint
#              _NAME   filename with no path
#              _PATH   relative path but no filename
#              _FILE   relative path with filename
#              _FULL   absolute mountpoint and path and filename
#              _DIR    varies

           VERSION="6.01.00"
      VERSION_DATE="Thu Apr 17 22:54:02 MDT 2014"
         DEVELOPER="BitJam"
         DEV_EMAIL="http://antix.freeforums.org"

        RETRY_TIME=15
     PERSIST_RETRY=10

           RW_MODE="ro"
            DISTRO="Linux"
            PRINTK=0

          LIVE_DIR="/live"
         FINAL_DIR="/live"
          LIVE_BIN="$LIVE_DIR/bin"

          AUFS_DIR="aufs"

       EXTRA_FILES="deb xtra"
       MIN_SYS_RAM=80
      MIN_AUFS_RAM=80

       DISTRO_FILE="/init.conf"
           LOG_DIR="/var/log/live"
          LOG_FILE="$LOG_DIR/bootstrap.log"

            MY_LOG=/init.log
           VID_DIR="/etc/live/version"
          VID_FILE="$VID_DIR/linuxfs.ver"
          MAKE_OLD="rootfs xtra deb"
           MOD_DIR="/lib/modules/$(uname -r)"

         FROM_TYPE="usb,cd"
     FROM_TYPE_ALL="usb,cd,hd"
          TOP_DIRS="bin boot etc lib lib64 opt root run sbin tmp usr var"
      TOP_BIN_DIRS="bin lib lib64 sbin usr"

     MAX_MOUNT_CNT=30
       RETRY_DELAY=50               # in hundredths of a second
           VERBOSE=5

        DO_HOTPLUG=true
        LOAD_FIRST="usb_common usbcore ehci-hcd"

          VID_NAME=VID
      LINUXFS_NAME=linuxfs

          USE_MDEV=
           DO_LOAD=

MKFS_FREE_MARGIN=20
  rootfs_SIZE_PARAM="min_size=64 mid_size=400 max_size=1000 factor=50"
  homefs_SIZE_PARAM="min_size=64 mid_size=400 max_size=1000 factor=25"

      MAX_MKFS_SIZE=4000
         MKFS_SIZES="65 100 150 200 250 375 500 750 1000 1500 2000 2500 3000 4000"
# Log msg statements to $LOG_FILE, First store them in $LOG variable.
            LOG=""

set_live_dirs() {
    local dir=$1

           BOOT_MP="$dir/boot-dev"
        ISO_DEV_MP="$dir/iso-dev"
       ISO_FILE_MP="$dir/iso-file"
          TORAM_MP="$dir/to-ram"
       AUFS_RAM_MP="$dir/aufs-ram"
           AUFS_MP="$dir/$AUFS_DIR"
         ROOTFS_MP="$dir/persist-root"
        PERSIST_MP="$dir/persist-dev"
           SQFS_MP="$dir/linux"         # where the linuxfs file gets *mounted*
      WRAP_FILE_MP="$dir/wrapper"
        OUTPUT_DIR="$dir/config"
        LOCALE_DIR="$dir/locale"
        CUSTOM_DIR="$dir/custom"
   GFX_SAVE_SCRIPT="$dir/bin/gfxsave.sh"
 DISABLED_USB_FILE="$OUTPUT_DIR/usb-disabled"
}


hbar="======================================================================"
tbar="----------------------------------------------------------------------"

main_wrapper() {

    local black blue green cyan red purple brown lt_gray dk_gray lt_blue
    local lt_green lt_cyan lt_red magenta yellow white rev_red
    local cheat_co cmd_co dev_co err_co from_co to_co head_co
    local hi_co mp_co m_co nc_co num_co ok_co bold_co

    PATH=$LIVE_BIN
    HOME=/
    TERM=linux
    PWD=/

    set_live_dirs $LIVE_DIR
    mkdir -p $OUTPUT_DIR

    # Don't allow interrupts to ruin our day
    #       HUP INT QUIT SEGV TERM
    trap "" 1   2   3    11   15

    umask 022
    mkdir -p /proc /sys /dev

    mount -t proc   proc  /proc
    mount -t sysfs  sys   /sys

    local time_0=$(cut -d" " -f22 /proc/$$/stat)

    make_nodes /dev

    custom_code $DISTRO_FILE
    custom_code 0 'before reading boot codes'

    read_cmdline_params

    [ -z "$USE_MDEV" ] && mount -t devtmpfs devtmpfs /dev
    mkdir -p /dev/pts
    mount -t devpts devpts /dev/pts

    FREE_MEM=$(mem_info MemFree)

    set_colors "$NO_COLOR" "$LOW_COLOR"

    read_xlat init $LANG
    clean_xlat

    # disable console screen blanking
    printf "\e[9;0]\e[14;0]"

    echo "$PRINTK" > /proc/sys/kernel/printk

    SCREEN_WIDTH=$(stty size 2>/dev/null | cut -d" " -f2)

    breakpoint 1 "before main_core"

    if [ "$NO_ERR_LOG" ]; then
        main_core
    else
        main_core 17>&1 1>&2 2>&17 | while read line; do echo "$line" \
            | sed -e "s/^/${yellow}Error: $red/" -e "s/$/$nc_co/" | tee -a $MY_LOG; done
    fi

    write_log_files $MY_LOG $NEW_ROOT/$LOG_FILE

    # Nota Bene: when error log is enabled,  main_core() runs in a subshell
    # so it cannot affect our variables.

    NEW_ROOT=$AUFS_MP

    breakpoint 9 "right before starting init"

    # re-enable console screen blanking at 15 minutes
    printf "\e[9;15]\e[14;15]"

    if find_init_prog INIT_PROG $NEW_ROOT; then

        vmsg 4 'Run %s instead of %s' $white$INIT_PROG$m_co $white/sbin/init$m_co
        vmsg 5 "${hi_co}%s" "Please exit shells normally to allow for a clean unmount"

        system_mount $NEW_ROOT

        CHROOT_BIN=$FINAL_DIR/bin
        chroot $NEW_ROOT $CHROOT_BIN/setsid $CHROOT_BIN/cttyhack $INIT_PROG

        breakpoint ch "after init= chroot"
        safe_shutdown poweroff ask

    else
        vmsg 6 "Start %s process" init
        exec $LIVE_BIN/switch_root -c /dev/console $NEW_ROOT /sbin/init "$@"
    fi
}

main_core() {
    [ "$NO_CLEAR" ] || printf "\e[1J"       # Clear and reset screen
    vmsg 6 "=== $0 bootstrap =================================================="

    vmsg 6 '%s started at %s seconds' $0 $(nq $(get_seconds $time_0))

    select_breakpoints

    if [ "$DO_MDEV" ]; then
        vmsg 6 'Populate %s with %s' $(dq /dev) $(cq mdev)
    else
        vmsg 6 'Populate %s with %s' $(dq /dev) $(cq devtmpfs)
    fi

    breakpoint 2 "before loading modules"

    start_hotplug "$DO_HOTPLUG" "$TRACE_LOAD"
    load_kernel_modules "$DO_LOAD" "$MODULE_LIST"

    do_welcome "$DISTRO" "$DISTRO_VERSION" "$DISTRO_CODENAME" "$VERSION" "$VERSION_DATE"

    show_bootcodes "$UNKNOWN_BOOTCODES"
    show_integer_errors "$INTEGER_ERRORS"

    : ${SQFILE_FILE:=$DEFAULT_SQFILE}
    : ${BOOT_DIR:=${SQFILE_FILE%/*}}
    : ${SQFILE_NAME:=${SQFILE_FILE##*/}}

    [ "$SQFILE_EXT" ] && SQFILE_NAME="$SQFILE_NAME.$SQFILE_EXT"
    SQFILE_FILE="$BOOT_DIR/$SQFILE_NAME"
    SQFILE_FILE=${SQFILE_FILE#/}

    # Wait and only do this in the find_files() loop so the usb report
    # will always work
    #[ "$NO_EHCI" ] && disable_hcd ehci

    #[ "$CRYPT_DEV" -o "$CRYPT_LABEL" -o "$CRYPT_UUID" ] && setup_crypt

    breakpoint 3 "before looking for linuxfs file"

    find_linuxfs_file

    RW_MODE=rw
    # FIXME: this makes debuggingg persist_makefs simpler
    #[ "$PERSIST_FILES" ] && mount -o remount,rw $SQFILE_DEV
    mount -o remount,rw $SQFILE_DEV

    breakpoint 4 "after mounting boot device"

    prepare_persistence

    mount_persist_device "$PERSIST_FILES" "$FROM_PERSIST"

    stop_hotplug
    list_modules

    # Check for ehci warning
    dmesg | grep 'Warning.*ehci' >&2

    breakpoint 5 "after mounting persistence device"

    fsck_boot_dev "$SQFILE_DEV" "$SQFILE_MP" "$SQFS_MP" "$SQFILE_FULL"  "$WRAP_FILE_MP"

    mount -o remount,rw $SQFILE_DEV 2>/dev/null
    dir_has_param "$SQFILE_MP" rw || REMASTERABLE=

    [ "$REMASTERABLE" ] && do_remaster "$SQFILE_MP/$SQFILE_PATH"

    ORIG_SQFILE_MP=$SQFILE_MP

    # Check md5 of files in directory containing linuxfs file
    # 'fromiso' causes us to check md5sums in two places
    [ "$CHECK_MD5" ] && check_md5 $SQFILE_DIR

    [ "$TO_RAM" ] && copy_to_ram $TORAM_MP

    mount_linuxfs "$SQFS_MP" "$SQFILE_FULL" "$WRAP_FILE_MP"

    breakpoint 6 "after mounting linuxfs file"

    check_kernel_version $SQFS_MP

    fsck_persist_dev "$PERSIST_FILES" "$PERSIST_DEVICE" "$PERSIST_MP"

    #dir_has_param "$PERSIST_MP" rw && mount -o remount,rw $PERSIST_MP

    [ "$WANT_ROOTFS" ] && remaster_rootfs "$PERSIST_MP" "$PERSIST_FULL_PATH"

    mount_aufs_ram "$AUFS_RAM_MP" "$MIN_AUFS_RAM" "$FREE_MEM"

    mount_and_copy_rootfs

    [ "$STATIC_ROOT" ] && log_cmd umount $AUFS_RAM_MP

    mount_aufs "$AUFS_MP" "$SQFS_MP" "$AUFS_RAM_MP" "$ROOTFS_MP"

    NEW_ROOT=$AUFS_MP

    [ "$USE_MDEV" ] && mdev -s
    breakpoint 7 "after mounting aufs"

    [ "$GFX_SAVE" ] && update_gfx_menu "$GFX_SAVE_SCRIPT" "$GFX_SAVE" "$BOOT_MP/boot"

    [ "$DELAYED_UMOUNT" ] && log_cmd umount $DELAYED_UMOUNT

    [ "$WANT_HOMEFS" ] && copy_homefs $PERSIST_FULL_PATH

    mount_persist_file 'homefs' $NEW_ROOT/home 'home' "$WANT_HOMEFS" "$NEED_HOMEFS" \
        && msg "Enabled %s persistence" "$(cq home)"

    [ "$DO_XTRA"       ] && copy_xtra    $DEFAULT_DIR
    [ "$DO_AUTO_LOGIN" ] && auto_login   "$AUTO_LOGIN_PROG" "$AUTO_LOGIN_TERMS" "$NEW_ROOT"
    [ "$DO_FANCY"      ] && fancy_prompt "$FANCY_PROMPT" "$NEW_ROOT"

    write_output_files     $OUTPUT_DIR
    old_write_output_files $OUTPUT_DIR

    breakpoint 8 "before prepare switch_root"

    [ -z "${FINAL_DIR##/*}" ] || FINAL_DIR="/$FINAL_DIR"

    prepare_switch_root $NEW_ROOT $LIVE_DIR $FINAL_DIR

    local time_1=$(get_time)
    local dt=$((time_1 - time_0))

    vmsg 6
    vmsg 4 "The %s program took %s seconds" $0 $(nq $(get_seconds $dt))
    vmsg 6 $hbar
}

#------------------------------------------------------------------------------
# Getting started
#------------------------------------------------------------------------------

system_mount() {
    local dir=$1
    shift

    mkdir -p $dir/proc $dir/sys $dir/dev

    mount -t proc   proc       $dir/proc
    mount -t sysfs  sys        $dir/sys

    for arg; do
        case $arg in
            dev)  mount -t devtmpfs devtmpfs $dir/dev  ;;
            tmp)  mount_tmpfs $dir/tmp     10
                  mount_tmpfs $dir/var/tmp 10          ;;
            etc)  mount --bind /live/etc      $dir/etc ;;
        esac
    done

    mkdir -p $dir/dev/pts
    mount -t devpts devpts     $dir/dev/pts

}

system_mountpoints() {
    local dev mp other ret=1 dir=$1

    while read dev mp other; do
        case $mp in $dir/*)
            echo -n "$mp "
            ret=0 ;;
        esac
    done << Read_Mounts
$(tac /proc/mounts)
Read_Mounts
    return $ret
}

system_umount() {
    local mp list i  dir=$1

    for i in $(seq 1 4); do
        list=$(system_mountpoints $dir) || return 0
        vmsg 7 'umount %s' "$(pq $list)"
        for mp in $list; do
            umount $mp
        done
    done
    list=$(system_mountpoints $dir) || return 0
    err "Unable to unmount %s" "$(hq $list)"
    return 1
}


make_nodes() {
    local dir=$1
    mkdir -p $dir

    [ -e $dir/console ] || mknod $dir/console c 5 1
    [ -e $dir/null    ] || mknod $dir/null    c 1 3
    [ -e $dir/tty0    ] || mknod $dir/tty0    c 4 0
}

#------------------------------------------------------------------------------
# Function read_cmdline_params
#
# Gather all boot codes
#------------------------------------------------------------------------------
read_cmdline_params()
{
    local ev param value

    # unset almost all env variables
    for ev in $(printenv | sed 's/=.*//'); do
        case $ev in
            HOME|PATH|PWD|TERM) continue;;
        esac
        unset $ev
    done

    for param in $(cat /proc/cmdline); do
        value=${param#*=}

        case $param in
               bootdir=*|bdir=*) BOOT_DIR=$value                                 ;;
    bootlabel=*|blabel=*|blab=*) BOOT_ID=label=$value                            ;;
             bootuuid=*|buuid=*) BOOT_ID=uuid=$value                             ;;
               bootdev=*|bdev=*) BOOT_ID=name=$value                             ;;

                  try=*|retry=*) valid_int RETRY_TIME $param                     ;;

            persistdir=*|pdir=*) PERSIST_PATH=${value#/}                         ;;

 persistlabel=*|plabel=*|plab=*) PERSIST_ID=label=$value  ;  SET_PERSIST=true    ;;
          persistuuid=*|puuid=*) PERSIST_ID=uuid=$value   ;  SET_PERSIST=true    ;;
            persistdev=*|pdev=*) PERSIST_ID=name=$value   ;  SET_PERSIST=true    ;;

 persistretry=*|pretry=*|ptry=*) valid_int PERSIST_RETRY $param                  ;;

#  cryptlabel=*|clabel=*|clab=*) CRYPT_LABEL=$value ;;
#           cryptuuid=*|cuuid=*) CRYPT_UUID=$value  ;;
#             cryptdev=*|cdev=*) CRYPT_DEV=$value   ;;

                      fromiso=*) ISO_FILE=${value/#}                             ;;
                        fromiso) FROM_ISO=true                                   ;;

                         from=*) FROM_TYPE=$value     ; ALWAYS_SCAN=true         ;;

                  persist=*|p=*) PERSIST=$PERSIST,$value                         ;;
                        persist) PERSIST=$PERSIST,root,home                      ;;

                        sqext=*) SQFILE_EXT=$value                               ;;
                       sqname=*) SQFILE_NAME=${value#/}                          ;;
                           sq=*) SQFILE_FILE=$value                              ;;

           verbose=*|verb=*|v=*) valid_int VERBOSE $param                        ;;
                           bp=*) BREAK_POINTS=$BREAK_POINTS,$value               ;;
                           pk=*) PRINTK=$value                                   ;;

             check|md5|checkmd5) CHECK_MD5=true                                  ;;
                 hico|highcolor) LOW_COLOR=                                      ;;
                  loco|lowcolor) LOW_COLOR=true                                  ;;
                   noco|nocolor) NO_COLOR=true                                   ;;

                         noxtra) DO_XTRA=                                        ;;
                         doxtra) DO_XTRA=true                                    ;;

                            db+) DO_AUTO_LOGIN=true; DO_FANCY=true; DB_PLUS=true ;;

            fancyprompt|fprompt) DO_FANCY=true                                   ;;
               autologin|alogin) DO_AUTO_LOGIN=true                              ;;

                          toram) TO_RAM=true                                     ;;

                     noremaster) NO_REMASTER=true                                ;;
                       rollback) ROLLBACK=true                                   ;;
                         lang=*) LANG=$value                                     ;;

                        noclear) NO_CLEAR=true                                   ;;
                      gfxsave=*) GFX_SAVE=$value                                 ;;

                        checkfs) FORCE_FSCK=true                                 ;;
                      nocheckfs) DO_FSCK=                                        ;;

                         load=*) MODULE_LIST=$MODULE_LIST,$value                 ;;
                           load) DO_LOAD=true                                    ;;
                         noload) DO_LOAD=                                        ;;

                      nohotplug) DO_HOTPLUG=                                     ;;
                      traceload) TRACE_LOAD=true                                 ;;
                 autoload|aload) FULL_AUTOLOAD=true                              ;;

                         init=*) INIT_PROG=$value                                ;;

                  nousb2|noehci) NO_EHCI=true                                    ;;

                       noerrlog) NO_ERR_LOG=true                                 ;;
                        errtest) TEST_ERRORS=true                                ;;
                      errtest=*) TEST_FATAL=$value                               ;;
                        noerr=*) NO_ERROR=$value                                 ;;

                           mdev) USE_MDEV=true                                   ;;
                         nomdev) USE_MDEV=                                       ;;
               livedir=*|ldir=*) FINAL_DIR=$value                                ;;

        #----- Some known codes -------------------------

        [sS1-6]|BOOT_IMAGE=*);;
        video.*);;

        # Most kernel codes from version 3.8
        acpi=*|acpi_rsdp=*|acpi_apic_instance=*|acpi_backlight=*);;
        acpi.debug_layer=*|acpi.debug_level=*|acpi_irq_balance);;
        acpi_irq_nobalance|acpi_irq_isa=*|acpi_irq_pci=*|acpi_no_auto_ssdt);;
        acpi_os_name=*|acpi_osi=*|acpi_pm_good|acpi_sci=*|acpi_serialize);;
        acpi_skip_timer_override|acpi_sleep=*|acpi_use_timer_override);;
        acpi_enforce_resources=*|add_efi_memmap|agp=*|ALSA|alignment=*);;
        align_va_addr=*|amd_iommu=*|amd_iommu_dump=*|amijoy.map=*);;
        analog.map=*|apc=*|apic=*|autoconf=*|show_lapic=*|apm=*|arcrimi=*);;
        ataflop=*|atarimouse=*|atkbd.extra=*|atkbd.reset=*|atkbd.set=*);;
        atkbd.scroll=*|atkbd.softraw=*|atkbd.softrepeat=*|baycom_epp=*);;
        baycom_par=*|baycom_ser_fdx=*|baycom_ser_hdx=*|boot_delay=*);;
        bootmem_debug|bttv.card=*|bttv.radio=*|bttv.pll=*|bttv.tuner=*);;
        bulk_remove=*|c101=*|cachesize=*|ccw_timeout_log|cgroup_disable=*);;
        checkreqprot|cio_ignore=*|clock=*|clocksource=*|clearcpuid=*|cma=*);;
        cmo_free_hint=*|coherent_pool=*|code_bytes|com20020=*|com90io=*);;
        com90xx=*|condev=*|conmode=*|console=*|consoleblank=*);;
        coredump_filter=*|cpuidle.off=*|cpcihp_generic=*|crashkernel=*);;
        cs89x0_dma=*|cs89x0_media=*|dasd=*|db9.dev[23]=*|ddebug_query=*|debug);;
        debug_locks_verbose=*|debug_objects|no_debug_objects);;
        debug_guardpage_minorder=*|debugpat|decnet.addr=*);;
        default_hugepagesz=*|dhash_entries=*|digi=*|digiepca=*|disable=*);;
        disable_ddw|disable_ipv6=*|disable_mtrr_cleanup|disable_mtrr_trim);;
        disable_timer_pin_1|dma_debug=*|dma_debug_entries=*);;
        dma_debug_driver=*|drm_kms_helper.edid_firmware=*|dscc4.setup=*);;
        dyndbg|dyndbg=*|module.dyndbg|module.dyndbg=*|earlycon=*);;
        earlyprintk=*|ekgdboc=*|edd=*|eisa_irq_edge=*|elanfreq=*|elevator=*);;
        elfcorehdr=*|enable_mtrr_cleanup|enable_timer_pin_1|enforcing);;
        erst_disable|ether=*|evm=*|failslab=*|fail_page_alloc=*);;
        fail_make_request=*|floppy=*|force_pal_cache_flush|ftrace=*);;
        ftrace_dump_on_oops|ftrace_dump_on_oops=*|ftrace_filter=*);;
        ftrace_notrace=*|ftrace_graph_filter=*|gamecon.map[23]=*|gamma=*);;
        gart_fix_e820=*|gcov_persist=*|gpt|grcan.enable0=*|grcan.enable1=*);;
        grcan.select=*|grcan.txsize=*|grcan.rxsize=*|hashdist=*|hcl=*|hd=*);;
        hest_disable|highmem=*|highres=*|hisax=*|hlt|hpet=*|hugepages=*);;
        hugepagesz=*|hvc_iucv=*|hvc_iucv_allow=*|keep_bootcon|i2c_bus=*);;
        i8042.debug|i8042.direct|i8042.dumbkbd|i8042.noaux|i8042.nokbd);;
        i8042.noloop|i8042.nomux|i8042.nopnp|i8042.notimeout|i8042.reset);;
        i8042.unlock|i810=*|i8k.ignore_dmi|i8k.force|i8k.power_status);;
        i8k.restricted|i915.invert_brightness=*|icn=*|ide-core.nodma=*);;
        ide-pci-generic.all-generic-ide|idle=*|ignore_loglevel);;
        ihash_entries=*|ima_appraise=*|ima_appraise_tcb|ima_audit=*);;
        ima_hash=*|ima_tcb|init=*|initcall_debug|initrd=*|inport.irq=*);;
        intel_iommu=*|intel_idle.max_cstate=*|intremap=*|iomem=*|iommu=*);;
        io7=*|io_delay=*|ip=*|ip2=*|irqfixup|irqpoll|isapnp=*|isolcpus=*);;
        iucv=*|js=*|keepinitrd|kernelcore=*|kgdbdbgp=*|kgdboc=*|kgdbwait);;
        kmac=*|kmemleak=*|kstack=*|kvm.ignore_msrs=*|kvm.mmu_audit=*);;
        kvm-amd.nested=*|kvm-amd.npt=*|kvm-intel.ept=*);;
        kvm-intel.emulate_invalid_guest_state=*|kvm-intel.flexpriority=*);;
        kvm-intel.nested=*|kvm-intel.unrestricted_guest=*|kvm-intel.vpid=*);;
        l2cr=*|l3cr=*|lapic|lapic=*|lapic_timer_c2_ok|libata.dma=*);;
        libata.ignore_hpa=*|libata.noacpi|libata.force=*|memblock=*);;
        load_ramdisk=*|lockd.nlm_grace_period=*|lockd.nlm_tcpport=*);;
        lockd.nlm_timeout=*|lockd.nlm_udpport=*|logibm.irq=*|loglevel=*);;
        log_buf_len=*|logo.nologo|lp=*|lpj=*|ltpc=*|machvec=*|machtype=*);;
        max_addr=*|maxcpus=*|max_loop=*|mce|mce=*|md=*);;
        mdacon=*|mem=*|memchunk=*|memmap=*|memory_corruption_check=*);;
        memory_corruption_check_size=*|memory_corruption_check_period=*);;
        memtest=*|meye.*=*|mfgpt_irq=*|mfgptfix|mga=*|min_addr=*|mini2440=*);;
        mminit_loglevel=*|module.sig_enforce|mousedev.tap_time=*);;
        mousedev.xres=*|mousedev.yres=*|movablecore=*|MTD_Partition=*);;
        MTD_Region=*|mtdparts=*|multitce=*|onenand.bdry=*|mtdset=*);;
        mtouchusb.raw_coordinates=*|mtrr_chunk_size=*|mtrr_gran_size=*);;
        mtrr_spare_reg_nr=*|n2=*|netdev=*|nf_conntrack.acct=*|nfsaddrs=*);;
        nfsroot=*|nfsrootdebug|nfs.callback_tcpport=*|nfs.cache_getent=*);;
        nfs.cache_getent_timeout=*|nfs.idmap_cache_timeout=*);;
        nfs.enable_ino64=*|nfs.max_session_slots=*);;
        nfs.nfs4_disable_idmapping=*|nfs.nfs4_unique_id=*);;
        nfs.send_implementation_id|nfsd.nfs4_disable_idmapping=*);;
        objlayoutdriver.osd_login_prog=*|nmi_debug=*|nmi_watchdog=*);;
        netpoll.carrier_timeout=*|no387|no_console_suspend|noaliencache);;
        noalign|noapic|noautogroup|nobats|nocache|noclflush|nodelayacct);;
        nodisconnect|nodsp|noefi|noexec|nosmap|nosmep|noexec32|nofpu|nofxsr);;
        noxsave|eagerfpu=*|nohlt|no-hlt|no_file_caps|nohalt|nohz=*|noiotrap);;
        noirqdebug|no_timer_check|noisapnp|noinitrd|nointremap|nointroute);;
        nojitter|no-kvmclock|no-kvmapf|no-steal-acc|nolapic|nolapic_timer);;
        noltlbs|nomca|nomce|nomfgpt|nonmi_ipi|nomodule|nopat|norandmaps);;
        noreplace-paravirt|noreplace-smp|noresidual|nordrand|noresume);;
        no-scroll|nosbagart|nosep|nosmp|nosoftlockup|nosync|notsc|nousb);;
        nowatchdog|nowb|nox2apic|cpu0_hotplug|nptcg=*|nr_cpus=*|nr_uarts=*);;
        numa_balancing=*|numa_zonelist_order=*|ohci1394_dma=*);;
        olpc_ec_timeout=*|omap_mux=*|oprofile.timer=*|oprofile.cpu_type=*);;
        oops=*|OSS|panic=*|parkbd.port=*|parkbd.mode=*|parport=*);;
        parport_init_mode=*|pause_on_oops=*|pcbit=*|pcd.|pci=*|pcie_aspm=*);;
        pcie_hp=*|pcie_ports=*|pcie_pme=*|pcmv=*|pd.|pdcchassis=*);;
        percpu_alloc=*|pf.|pg.|pirq=*|plip=*|pmtmr=*|pnp.debug=*|pnpacpi=*);;
        pnpbios=*|pnp_reserve_irq=*|pnp_reserve_dma=*|pnp_reserve_io=*);;
        pnp_reserve_mem=*|ports=*|print-fatal-signals=*);;
        printk.always_kmsg_dump=*|printk.time=*|processor.max_cstate=*);;
        processor.nocst|profile=*|prompt_ramdisk=*|psmouse.proto=*);;
        psmouse.rate=*|psmouse.resetafter=*|psmouse.resolution=*);;
        psmouse.smartscroll=*|pstore.backend=*|pt.|pty.legacy_count=*|quiet);;
        r128=*|raid=*|ramdisk_blocksize=*|ramdisk_size=*|rcu_nocbs=*);;
        rcu_nocb_poll|rcutree.blimit=*|rcutree.fanout_leaf=*);;
        rcutree.qhimark=*|rcutree.qlowmark=*|rcutree.rcu_cpu_stall_suppress=*);;
        rcutree.rcu_cpu_stall_timeout=*|rcutree.jiffies_till_first_fqs=*);;
        rcutree.jiffies_till_next_fqs=*|rcutorture.fqs_duration=*);;
        rcutorture.fqs_holdoff=*|rcutorture.fqs_stutter=*);;
        rcutorture.irqreader=*|rcutorture.n_barrier_cbs=*);;
        rcutorture.nfakewriters=*|rcutorture.nreaders=*);;
        rcutorture.onoff_holdoff=*|rcutorture.onoff_interval=*);;
        rcutorture.shuffle_interval=*|rcutorture.shutdown_secs=*);;
        rcutorture.stall_cpu=*|rcutorture.stall_cpu_holdoff=*);;
        rcutorture.stat_interval=*|rcutorture.stutter=*);;
        rcutorture.test_boost=*|rcutorture.test_boost_duration=*);;
        rcutorture.test_boost_interval=*|rcutorture.test_no_idle_hz=*);;
        rcutorture.torture_type=*|rcutorture.verbose=*|rdinit=*|reboot=*);;
        relax_domain_level=*|reserve=*|reservetop=*|reservelow=*);;
        reset_devices|resume=*|resume_offset=*|resumedelay=*|resumewait);;
        hibernate=*|retain_initrd|rhash_entries=*|riscom8=*|ro|root=*);;
        rootdelay=*|rootflags=*|rootfstype=*|rootwait|rw|S|sa1100ir|sbni=*);;
        sched_debug|skew_tick=*|security=*|selinux=*|apparmor=*|serialnumber);;
        shapers=*|show_msr=*|simeth=*|simscsi=*|slram=*|slab_max_order=*);;
        slub_debug|slub_debug=*|slub_max_order=*|slub_min_objects=*);;
        slub_min_order=*|slub_nomerge|smart2=*|smsc-ircc2.nopnp);;
        smsc-ircc2.ircc_cfg=*|smsc-ircc2.ircc_sir=*|smsc-ircc2.ircc_fir=*);;
        smsc-ircc2.ircc_irq=*|smsc-ircc2.ircc_dma=*);;
        smsc-ircc2.ircc_transceiver=*|softlockup_panic=*|sonypi.*=*);;
        specialix=*|spia_io_base=*|spia_fio_base=*|spia_pedr=*|spia_peddr=*);;
        stacktrace|stacktrace_filter=*|sti=*|sti_font=*|stifb=*);;
        sunrpc.min_resvport=*|sunrpc.max_resvport=*|sunrpc.pool_mode=*);;
        sunrpc.tcp_slot_table_entries=*|sunrpc.udp_slot_table_entries=*);;
        swapaccount|swapaccount=*|swiotlb=*|switches=*|sysfs.deprecated=*);;
        sysrq_always_enabled|tdfx=*|test_suspend=*|thash_entries=*);;
        thermal.act=*|thermal.crt=*|thermal.nocrt=*|thermal.off=*);;
        thermal.psv=*|thermal.tzp=*|threadirqs|topology=*|tp720=*);;
        tpm_suspend_pcr=*|trace_buf_size=*|trace_event=*|trace_options=*);;
        transparent_hugepage=*|tsc=*|turbografx.map[23]=*|udbg-immortal);;
        uhash_entries=*|uhci-hcd.ignore_oc=*|unknown_nmi_panic);;
        usbcore.authorized_default=*|usbcore.autosuspend=*);;
        usbcore.usbfs_snoop=*|usbcore.blinkenlights=*);;
        usbcore.old_scheme_first=*|usbcore.usbfs_memory_mb=*);;
        usbcore.use_both_schemes=*|usbcore.initial_descriptor_timeout=*);;
        usbhid.mousepoll=*|usb-storage.delay_use=*|usb-storage.quirks=*);;
        user_debug=*|userpte=*|vdso=*|vdso32=*|vector=*|video=*);;
        virtio_mmio.device=*|vga=*|vmalloc=*|vmhalt=*|vmpanic=*|vmpoff=*);;
        vsyscall=*|vt.cur_default=*|vt.default_blu=*|vt.default_grn=*);;
        vt.default_red=*|vt.default_utf8=*|vt.global_cursor_default=*);;
        watchdog|x2apic_phys|x86_mrst_timer=*|xd=*|xd_geo=*|xen_emul_unplug=*);;
        xirc2ps_cs=*);;

        nomodeset|*.modeset=*);;
        nosplash|splash=*|fbcon=*);;

        #----------------------------------------------------------------------
        # NOTE: see /live/custom/$DISTRO/1.sh for distro specific boot codes
        #----------------------------------------------------------------------

        *) UNKNOWN_BOOTCODES="$UNKNOWN_BOOTCODES $param"
        esac
    done
}

valid_int() {
    local var=$1 val=${2#*=} name=${2%%=*} param=$2

    case $val in
                      "")                   return ;;
        [0-9]|[0-9][0-9]) eval $var=\$val;  return ;;

    esac
    INTEGER_ERRORS="$INTEGER_ERRORS $param"
}

start_hotplug() {
    local do_hotplug=$1  trace_load=$2

    # Set up file for recording sequence of kernel events sent to mdev
    echo > /dev/mdev.seq
    if [ "$trace_load" ]; then
        echo $LIVE_BIN/mdev-trace > /proc/sys/kernel/hotplug
    elif [ -n "$do_hotplug" ]; then
        echo $LIVE_BIN/mdev-hotplug > /proc/sys/kernel/hotplug
    fi

    [ "$USE_MDEV" ] && mdev -s
}

stop_hotplug() { echo > /proc/sys/kernel/hotplug; }

list_modules() {
    local mod list cnt=0
    list=$( echo $(lsmod | grep "^[a-z]" | cut -d" " -f1) | sort)
    cnt=$(echo $list | wc -w)

    #. loaded <count> modules(s)
    vmsg 6 "Loaded %s module(s)" $(nq $cnt)

    [ "$list" ] && vmsg 7 "$white$list"

    [ "$ERR_MODULES" ] || return
    local ecnt=$(echo "$ERR_MODULES" | wc -w)

    #. <count> module(s) failed to load
    vmsg 6 "%s module(s) failed to load" $(nq $ecnt)

    vmsg 7 "$white$ERR_MODULES"

}

select_breakpoints() {
    case $BREAK_POINTS in
        *\?*|*ask*)
            echo
            echo "${m_co}Remaining $hi_co$0$m_co breakpoints:$nc_co"
            echo
            sed -rn 's/^\s*breakpoint ([1-9a-z][0-9a-z]?)/  \1)/p' $0 | sed "s/['\"]//g" | sort
            echo
            echo "${m_co}Use \"a\" to set most breakpoints$nc_co"
            echo "${m_co}Use \"A\" to set all breakpoints$nc_co"
            echo
            printf "${ok_co}%s$m_co: $nc_co" "Enter breakpoint(s) separated by commas"
            setsid cttyhack > /dev/null
            read BREAK_POINTS;;
    esac
}

mem_info() {
    local info amt kb
    while read info amt kb; do
        [ ! "$info" = "$1:" ] && continue
        echo $((amt / 1024))
        return
    done </proc/meminfo
}

clean_xlat() {
    find $LOCALE_DIR/xlat -name init.xlat -delete
    rm -rf $LOCALE_DIR/fonts
}

read_xlat() {
    local prog=$1  lang=$2
    local xdir=$LOCALE_DIR/xlat
    local fdir=$LOCALE_DIR/fonts

    local xlat=$xdir/en/$prog.xlat
    [ -r $xlat ] && . $xlat

    [ "$lang" ] || return

    lang=$(echo $lang | sed 's/_.*//')

    xlat=$xdir/$lang/$prog.xlat
    [ -r "$xlat" ] || return
    . $xlat
    vmsg 7 'Translate to %s' $lang

    local font=$fdir/$lang
    [ -e "$font" ] && log_cmd setfont $font -C $(tty)
}

do_welcome() {

    [ "$NO_CLEAR" ] || clear   # Clear and reset screen

    local distro=$1  d_version=$2  d_codename=$3  version=$4  v_date=$5
    local welcome_name

    welcome_name=$distro
    [ "$d_version" ]  && welcome_name="$welcome_name-$d_version"
    [ "$d_codename" ] && welcome_name="$welcome_name${hi_co} $d_codename"
    vmsg 2 "Welcome to %s" "$(pq $welcome_name)!"

    # Get total ramsize, and available real ram in MB. We need this later.

    local total_mem=$(mem_info MemTotal)
    local used_mem=$((total_mem - FREE_MEM))

    vmsg 6 "$white  $(busybox | head -n 1)"

    [ -x /bin/ntfs-3g ] && vmsg 6 "$white  $(ntfs-3g --version 2>&1)"

    vmsg 6 "%25s: $white%s"  "$0 version" "$version"
    vmsg 6 "%25s: $white%s"  "$0 built"   "$v_date"

    # Print meminfo.
    local mem_format="${m_co}%s: $num_co%5d${m_co} M"
    vmsg 6 "$mem_format"  "             Total Memory" $total_mem
    # vmsg 6 "$mem_format"  "              Free Memory"  $FREE_MEM
    vmsg 6 "$mem_format"  "              Used Memory"  $used_mem

    local cpu_format="%s:$white %s"
    vmsg 6 "$cpu_format"  "             Linux kernel" "$(uname -r)"
    vmsg 6 "$cpu_format"  "             Screen width" "$SCREEN_WIDTH"

    # vmsg 6 "$cpu_format"  "             Architecture" "$(uname -m)"

    # vmsg 6  "$cpu_format" "                      CPU" "$(cpu_param 'model name' unknown)"
    # vmsg 6  "$cpu_format" "                    Cores" "$num_co$(cpu_param 'cpu cores'  1)"
    # vmsg 6  "$cpu_format" "                    Cache" "$(cpu_param 'cache size' unknown)"
}

show_bootcodes() {
    local unknown=$1

    vmsg 5 "%s:" "Current boot codes"
    vmsg 5 "    $white $(cat /proc/cmdline)"

    [ -n "$unknown"  -a -n "$CHECK_BOOTCODES" ] || return

    vmsg 4
    vmsg 4 "$warn_co%s:" "Possibly unknown or misspelled boot codes"
    vmsg 4 "(%s)" "don't take this too seriously"
    local code
    for code in $unknown; do
        vmsg 4 "$hi_co    $code"
    done
    vmsg 4

}

show_integer_errors() {
    local param name value params=$1

    #. Only small integer values are allowed for <name>.  Will ignore <name=value>
    for param in $params; do
        name=${param%%=*}
        value=${param#*=}
        warn "Only small integer values are allowed for %s.  Will ignore %s" \
            $(pqw $name) $(pqw $param)
    done
}

cpu_param() {
    local result=$(grep "^$1" /proc/cpuinfo | head -n 1 | sed 's/.*\t: //')
    [ "$result" ] || result=$2
    echo "$result"
}

disable_hcd() {
    local type=$1
    local dir=/sys/bus/pci/drivers/${type}_hcd
    local symlink kmsg=/dev/kmsg
    for symlink in $(find $dir -name "0*" | sed 's=.*/=='); do
        echo $symlink >> $DISABLED_USB_FILE.$type
        msg 'disable %s bus: %s' $(nq $type) $(pq $symlink)
        [ -e $kmsg ] && echo "$0 disabled $type: $symlink" >> $kmsg
        echo $symlink > $dir/unbind
    done
}

load_kernel_modules() {
    local module  do_load=$1  list=$2  file=$CUSTOM_DIR/$DISTRO/modules.load

    depmod &>/dev/null

    mkdir -p $MOD_DIR
    # This one must be loaded before the others
    for mod in $LOAD_FIRST; do
        #load_module $mod
        modprobe -q $mod 2>/dev/null
    done

    if [ -r $file -a -n "$do_load" ]; then
        vmsg 7 'Load modules from file %s' "$(fq $file)"
        for module in $(grep -v "^\s*#" $file | sed 's/\s*#.*//' ); do
            load_module $module
        done
    fi

    autoload_modules 6

    # . Could not load module <module-name>
    for module in $(echo $list | sed 's/,/ /g'); do
        case $module in
            all) load_all_modules ;;
              *) load_module $module || warn "Could not load module %s" $(pqw $module);;
        esac
    done
}

load_all_modules() {

    msg "Loading all live modules"
    local list=$(find $MOD_DIR/live -name "*.ko" | sed -e 's=.*/==' -e 's/\.ko$//')
    local module
    for module in $list; do
        load_module $module
    done
}

autoload_modules() {
    local alias  module  count  verb=$1
    [ "$verb" ] && vmsg $verb "Load hardware specific modules"
    for alias in $(find /sys/devices -name modalias -print0 | xargs -0 cat 2>/dev/null| sort -u); do
        $LIVE_BIN/modprobe -q $alias &>/dev/null
        [ "$TRACE_LOAD" ] && echo $alias >> /live/config/auto-load.out
    done

    [ "$USE_MDEV" ] && mdev -s
}

load_module() {
    local name=$1

    #vmsg $level "Load module:$dev_co $name"
    #log_cmd modprobe $name
    local msg=$(modprobe $name 2>&1 1>/dev/null)
    [ "$msg" ] || return 0
    ERR_MODULES="$ERR_MODULES $name"
    return 1
}

setup_crypt() {
    msg 'Look for encrypted device ...'

    # FIXME: convert retry to final_try or retry_time
    find_crypt_device "$RETRY_TIME" || fatal 'Could not find encrypted device.'

    # No labels on encrypted partitions so bump the partition number if using label
    if [ "$CRYPT_LABEL" -a -z "$CRYPT_DEV" ]; then
        NEXT_DEVICE="$(next_device $DEVICE_LIST)" || fatal 'Could not find encrypted device after: %s' "$DEVICE_LIST"
        DEVICE_LIST=$NEXT_DEVICE
    fi

    [ "$DEVICE_LIST" ] || fatal 'Strange, could not find encrypted device.'
    CRYPT_DEVICE=$DEVICE_LIST

    msg 'Found encrypted partition: %s' "$CRYPT_DEVICE"

    if cryptsetup isLuks $CRYPT_DEVICE; then
        cryptsetup luksOpen $CRYPT_DEVICE boot
    else
        cryptsetup create   boot $CRYPT_DEVICE
    fi

    PERSIST_ID=name=/dev/mapper/boot

    [ "$BOOT_ID" ] || BOOT_ID=name=/dev/mapper/boot

    for module in dm-crypt dm-mod serpent sha256 blowfish aes; do
        load_module $module
    done
}

#==============================================================================
# Find the squashfs file
#==============================================================================

#------------------------------------------------------------------------------
# Function: is_usb_or_removable <device>
#------------------------------------------------------------------------------

is_usb_or_removable() {
    local short_dev=${1##*/}
    local dir=/sys/block/${short_dev%%[0-9]*}/
    [ "$(cat $dir/removable 2>/dev/null)" = 1 ] && return 0
    local devpath=$(readlink -f $dir/device)
    [ "$devpath" ] || return 1
    echo $devpath | grep -q /usb
    return $?
}

#------------------------------------------------------------------------------
# Function: from_filter <device-list>
#
# Filter and order devices in list according to types listed in $FROM_TYPE.
# Output goes into FILTERED_LIST so we can give error messages from within.
# Return true if there is at least one item in the FILTERED_LIST otherwise
# return false.  Error out if there is an invalid from= type.
#
# See LINUX ALLOCATED DEVICES for device numbers
# https://www.kernel.org/doc/Documentation/devices.txt
#------------------------------------------------------------------------------
from_filter() {

    FILTERED_LIST=

    local from_type invalid_scan
    case ,$FROM_TYPE, in
        *,all,*) from_type=$FROM_TYPE_ALL;;
              *) from_type=$FROM_TYPE;;
    esac

    # First segregate devices by type
    local dev cd_devs hd_devs usb_devs
    for dev; do
        [ -b "$dev" ] || continue
        case $(stat -c %t $dev) in

            b) cd_devs="$cd_devs $dev" ;;
         [38]) if is_usb_or_removable $dev; then
                    usb_devs="$usb_devs $dev"
                else
                    hd_devs="$hd_devs $dev"
                fi ;;
        esac
    done

    local type
    for type in $(echo $from_type | sed 's/,\+/ /g'); do
        case $type in

            cd) FILTERED_LIST="$FILTERED_LIST$cd_devs"
                cd_devs= ;;

            usb) FILTERED_LIST="$FILTERED_LIST$usb_devs"
                usb_devs= ;;

            hd) FILTERED_LIST="$FILTERED_LIST$hd_devs"
                hd_devs= ;;

           "") ;;

            *) invalid_scan="$invalid_scan $type";;
        esac
    done

    #. Invalid <parameter-name> value(s) <bad values>
    [ "$invalid_scan" ] \
        && _fatal "$(printf "Invalid %s values(s) %s" "$(pqh from=)" "$(pqh $invalid_scan)")" \
        "$(printf "Valid values are %s" "$(cq cd hd usb all)")"

    [ "$FILTERED_LIST" ]

    return $?
}

find_boot_file() {
    local ret file=$2
    find_files boot "$@"
    ret=$?

    case $ret in
        10) fatal "No %s devices found" block             ;;
        20) fatal "No %s devices found" $(pqh $FROM_TYPE) ;;
        30) _fatal "" \
            "$(printf "The %s parameter is blocking device %s" \
            $(pqh from=$FROM_TYPE) "$(pqh $DEVICE_LIST)")"     \
            "$(printf "Even though device %s has %s" "$(pqh $DEVICE_LIST)" "$(pqh $device_id)")" \
            "$(printf "Remove the %s boot parameter to allow that device to be scanned" \
            $(cq $FROM_TYPE))" ;;
        40) fatal "Device found but could not find %s file on device"  $(pqh $file) ;;
    esac

    return $ret
}

#------------------------------------------------------------------------------
# Function: find_files <files> <mntpnt> <dev> <label> <uuid> <retry>
#
# The outer wrapper lets us show the loop times regardless of how we left the
# main code in _find_files().
#------------------------------------------------------------------------------

find_files() {
    local ret loop_times start_t=$(get_time) t2 elapsed  find_type=$1 files=$2 device_id=$4
    _find_files "$@"
    ret=$?
    t2=$(get_time)
    elapsed=$(get_seconds $((t2 - start_t)))
    vmsg 6 "Spent %s seconds looking for %s file(s) %s" $(nq $elapsed) $(fq $find_type) "$(fq $files)"
    [ "$loop_times" ] && vmsg 6 "loop times:$num_co$loop_times"

    [ "$find_type" != boot ] && return $ret

    return $ret
}

_find_files() {
    local find_type=$1 files=$2  mp_orig=$3  device_id=$4  retry_time=$5

    local last_list

    unset FOUND_DEV FOUND_MP

    local be_verbose vthresh=8
    [ "$VERBOSE" -ge $vthresh ] && be_verbose=true

    mkdir -p "$mp_orig"

    local end_t  loop_t1  usleep  dt
    local start_t=$(get_time)  current_t=0
    local try=-1  have_devices  final_try  dot=.  dt_secs

    # Stay in loop until success or time goal_t is reached
    local goal_t=$((start_t + retry_time * 100))

    local do_delay said_retry mounted_device

    while [ -z "$final_try" ]; do

        try=$((try + 1))
         [ "$be_verbose" ] && cnt_up=$(nq "$(printf "%2d" $try)")

        #-- delay every time except inside first second
        if [ "$do_delay" ]; then
            if [ -z "$said_retry" ]; then
                vmsgN 4 "Retry for %s seconds " $(nq $retry_time)
                vmsg_if $vthresh " ..."
                said_retry=true
            fi

            [ "$FULL_AUTOLOAD" ] && autoload_modules

            # Normally just print out a dot for each iteration
            [ "$be_verbose" ] || msgN $dot

            # Adjust sleep time dynamically to account for previous time
            # through the loop

            current_t=$(get_time)
            dt=$((current_t - loop_t1))
            usleep=$(( ($RETRY_DELAY - dt ) * 10000))
            dt_secs=$(get_seconds $dt)
            loop_times="$loop_times $dt_secs"
            vmsg_if 9 "loop time:$num_co $dt_secs"

            # Once we have exceeded the time limit we go through the
            # loop one final time.
            [ $current_t -gt $goal_t ] && final_try=true

            # Only sleep long enough so total time through loop is constant
            [ $usleep -gt 0 ] && usleep $usleep
        else
            [ $(($(get_time) - start_t)) -gt 99 ] && do_delay=true
        fi

        loop_t1=$(get_time)

        # This disables usb-2
        [ "$NO_EHCI" ] && disable_hcd ehci

        unset DEVICE_LIST FILTERED_LIST

        #----------------------------------------------------------------------
        # Either scan all available block devices because no uuid, label, or
        # device was specified ...
        #----------------------------------------------------------------------
        if [ -z "$device_id" ]; then

            #. Scan <type> devices for <type> file(s) <file names>
            [ "$try" = "0" ] \
                && vmsg 4 "Scan %s devices.  Look for %s file(s) %s"  $(dq $FROM_TYPE) $find_type "$(fq $files)"

            DEVICE_LIST=$(most_block_devices)

            if [ -z "$DEVICE_LIST" ]; then
                [ "$final_try" ] && return 10

                vmsg_if $vthresh "%s No %s devices found" "$cnt_up" block
                continue
            fi

            # Filter and order devices according to from= parameter
            if ! from_filter $DEVICE_LIST; then
                [ "$final_try" ] && return 20

                vmsg_if $vthresh "%s No %s devices found" "$cnt_up" $(pq $FROM_TYPE)
                continue
            fi

            DEVICE_LIST=$FILTERED_LIST

            # pure window dressing
            if [ -z "$have_devices" ]; then
                [ $try -gt 0 ] && vmsg 5
                vmsg 5 "Filtered devices %s" "$white$DEVICE_LIST"
            else
                vmsg_if $vthresh "%s Filtered devices %s" "$cnt_up" "$(pq $DEVICE_LIST)"
            fi

        #----------------------------------------------------------------------
        # ... Or look for specific devices because a uuid, label, or device was
        # specified
        #----------------------------------------------------------------------
        else
            # FIXME: perhaps only do this for name= and uuid= not label=
            [ "$mounted_device" ] && return 40

            find_device "$find_type" "$try" "$final_try" "$device_id" || return $?
            if [ -z "$DEVICE_LIST" ]; then
                vmsg_if $vthresh "%s No %s devices yet found" "$cnt_up" $(pq $FROM_TYPE)
                continue
            fi

            #------------------------------------------------------------------
            # When a device has been specified via label, uuid, or /dev/node
            # then only filter and order if from= parameter is given explicitly
            #------------------------------------------------------------------
            if [ "$ALWAYS_SCAN" ]; then
                if ! from_filter $DEVICE_LIST; then
                    [ "$final_try" ] && return 30
                    continue
                fi

                DEVICE_LIST=$FILTERED_LIST
            fi

            # pure window dressing
            if [ -z "$have_devices" ]; then
                [ "$try" != "0" ] && msg
                #. Look for files(s) <file-list> on device(s) <device list>
                vmsg 4 "Look for file(s) %s on device(s) %s" "$(pq $files)" "$(dq $DEVICE_LIST)"
            else
                #vmsg_if $vthresh
                vmsg_if $vthresh "%s Look for %s on %s" "$cnt_up" "$(pq $files)" "$(dq $DEVICE_LIST)"
            fi
        fi

        #----------------------------------------------------------------------
        # Now we have some device or devices to mount and search
        #----------------------------------------------------------------------

        # more window dressing
        if [ -n "$have_devices" -a "$last_list" != "$DEVICE_LIST" ]; then
            msg
            msg "Found new device(s) %s" "$(hq $DEVICE_LIST)"
        fi
        last_list=$DEVICE_LIST

        have_devices=true

        #-- now try to mount each device and find at least one of the $files ...
        local dev fname mntpnt mounted already
        for dev in $DEVICE_LIST; do

            # use existing mountpoint if device is already mounted
            mntpnt="$(get_mountpoint $dev)"
            if [ "$mntpnt" ]; then
                mounted=
                mounted_device=true
                [ "$already" ] || vmsg 5 "Device %s is already mounted at %s"  "$(dq $dev)" "$(mpq $mntpnt)"
                already=true
            else
                try_mount $dev $mp_orig || continue
                mounted_device=true
                mounted=true
                mntpnt=$mp_orig
            fi

            for fname in $files; do
                [ -f "$mntpnt/$fname" ] || continue
                if [ "$mntpnt" = "$mp_orig" ]; then
                    #. Mounted <type> <device> at <mount point>
                    vmsg 4 "Mounted %s device. Mounted device %s at %s" \
                        $find_type "$(fq $dev)" "${to_co}$mntpnt${m_co}"

                    #. <type> device filesystem: <filesystem-name>
                    vmsg 5 "%s device filesystem: %s" $find_type \
                        "$(cq $(grep " $mntpnt " /proc/mounts | cut -d" " -f3,4))"

                    local short_dev=${dev##*/}
                    local model=$(cat /sys/block/${short_dev%%[0-9]*}/device/model 2>/dev/null)

                    #. <type> device model: <model-name>
                    [ "$model" ] && vmsg 6 "%s device model: %s" $find_type "$(cq $model)"

                else
                    rmdir $mp_orig
                fi
                FOUND_DEV=$dev
                FOUND_MP=$mntpnt
                return 0
            done
            [ "$mounted" ] && mountpoint -q $mp_orig && umount $mp_orig
        done
    done
    [ "$try" != "0" ] && msg
    return 90
}

#------------------------------------------------------------------------------
# Function find_device: <type> <try> <final_try> <device_id>
#
# Find the device(s) associated with a device name, a label, or a uuid.  Puts
# the result in $DEVICE_LIST so are free to echo error messages.  Returns true
# on success or if we need to retry.  Returns false if there was a final error.
#------------------------------------------------------------------------------

find_device() {
    local err_ret find_type=$1  try=$2  final_try=$3  type=${4%%=*}  value=${4#*=}

    DEVICE_LIST=

    #. Look for <type> devices with <attribute X>
    [ "$try" = 0 ] && msg "Look for %s device with %s" "$(fq $find_type)" "$type $(cq $value)"

    case $type in
        name) DEVICE_LIST=$(cleanse_dev  $value)  ; err_ret=1 ;;
       label) DEVICE_LIST=$(label_to_dev $value)  ; err_ret=2 ;;
        uuid) DEVICE_LIST=$(uuid_to_dev  $value)  ; err_ret=3 ;;
           *) fatal 'Internal error: find_device() type=%s value=%s' "$type" "$value" ;;
    esac

    [ "$DEVICE_LIST" ] && return 0
    [ "$final_try" ]   || return 0

    [ "$try" != 0 ] && msg

    [ "$AUTO_PERSIST" ] && return 100

    general_device_error "$find_type" "$type" "$value"
    return $err_ret
}

device_uuid() {
    local device=$1 LABEL TYPE UUID
    eval $(blkid $device | sed 's/^[^:]*://')
    echo $UUID
}

find_linuxfs_file() {

    if [ -n "$ISO_FILE" -o -n "$FROM_ISO" ]; then

        : ${ISO_FILE:=$DEFAULT_ISO_FILE}
        ISO_FILE=${ISO_FILE#/}

        heading "${cheat_co}fromiso"

        #. Could not find <type> file <file name>
        find_boot_file "$ISO_FILE" "$ISO_DEV_MP" "$BOOT_ID" "$RETRY_TIME" \
            || fatal "Could not find %s file %s" iso "$(pqh $ISO_FILE)"

        local iso_full=$ISO_DEV_MP/$ISO_FILE
        DEFAULT_PERSIST_PATH=${ISO_FILE%/*}

        # Check md5 of files in directory containing iso file
        [ "$CHECK_MD5" ] && check_md5 $iso_full

        # Mount the iso file
        mkdir -p $ISO_FILE_MP
        mount -t iso9660 -o loop,ro $iso_full $ISO_FILE_MP \
            || fatal "Could not mount %s as a %s file" "$(pqh $iso_full)" 'iso'

        # Find the linuxfs file
        SQFILE_FULL="$ISO_FILE_MP/$SQFILE_FILE"
        [ -f "$SQFILE_FULL" ] \
            || linuxfs_error "File %s not found on device %s" "$LINUXFS_NAME" "$SQFILE_FULL" "$FOUND_DEV"

        SQFILE_MP=$ISO_FILE_MP
        SQFILE_DEV=$FOUND_DEV   # Used for toram-eject

    else

        find_boot_file "$SQFILE_FILE" "$BOOT_MP" "$BOOT_ID" "$RETRY_TIME" \
            || linuxfs_error "Could not find %s file %s" "$LINUXFS_NAME" "$(fqe \"$SQFILE_FILE\")"

        SQFILE_MP=$BOOT_MP

        SQFILE_DEV=$FOUND_DEV

        mount -o remount,rw $BOOT_MP &>/dev/null
        dir_has_param "$BOOT_MP" rw && REMASTERABLE=true
        mount -o remount,rw $BOOT_MP &>/dev/null

        SQFILE_FULL=$BOOT_MP/$SQFILE_FILE
        SQFILE_PATH=${SQFILE_FILE%/*}
        DEFAULT_PERSIST_PATH=$SQFILE_PATH

    fi

    SQFILE_DIR=$SQFILE_MP/$SQFILE_PATH
    DEFAULT_DIR=$SQFILE_DIR
}

linuxfs_error() {
    local msg=$(printf "$@")  device_list=$(echo $DEVICE_LIST)
    local all_devices=$(echo $(most_block_devices));

    _fatal "$msg" \
        "$(printf "     Searched devices: %s" "${hi_co}$device_list")" \
        "$(printf "       Searched types: %s" "${hi_co}$FROM_TYPE")"   \
        "$(printf "    All block devices: %s" "${hi_co}$all_devices")" \
        "" \
        "$(printf "Please contact %s at %s" "$DEVELOPER" "$DEV_EMAIL")"
}

check_kernel_version() {
    local mp=$1
    local kversion=$(uname -r)
    local mod_dir=/lib/modules/$kversion

    [ -d $mp$mod_dir ] && return

    _non_fatal "Kernel version mismatch" \
        "$(printf "Kernel version %s" $(pqh $kversion))" \
        "$(printf "The module directory %s is missing" $(pqh $mp$mod_dir))"
}

#==============================================================================
# Mount things
#==============================================================================

mount_linuxfs() {

    local sqfs_mp=${1:-$SQFS_MP}  sqfile_full=${2:-$SQFILE_FULL}  \
        wrap_mp=${3:-$WRAP_FILE_MP}  vid_file=$1$VID_FILE

    mkdir -p $sqfs_mp
    vmsg 6 "Mount file %s at %s" "$(fq $sqfile_full)" "$(fq $sqfs_mp)"
    #. Could not mount <file name> as a <type> filesystem
    log_cmd mount -t squashfs -o loop,ro $sqfile_full $sqfs_mp \
        || fatal "Could not mount %s as a %s filesystem" $sqfile_full squashfs

    if [ -n "$wrap_mp" -a -e "$sqfs_mp/$SQFILE_NAME" -a ! -d "$sqfs_mp/usr" ]; then
        msg 'Found wrapped filesystem. Move wrapper ...'
        mkdir -p $wrap_mp
        mount --move $sqfs_mp $wrap_mp

        try_file_mount  $wrap_mp/$SQFILE_NAME $sqfs_mp ro \
            || fatal "Could not mount %s as a %s file" $sqfile_full 'filesystem'
    fi

    #link_top_dirs $sqfs_mp $TOP_BIN_DIRS

    #set_path $LIVE_BIN:/sbin:/bin/usr/sbin:/usr/bin

    SQFS_VID=$(get_vid $vid_file)

    if [ "$SQFS_VID" ]; then
        vmsg 7 'sqfs_vid: %s' "$nc_co$SQFS_VID"
    else
        vmsg 7 "No %s found at %s" "$VID_NAME" "$white$vid_file$m_co"
    fi
    SQFS_VID_FILE=$vid_file
}

mount_aufs_ram() {
    local aufs_ram_mp=$1  min_aufs_ram=$2  free_mem=$3
    # Default tempfs size for tempfs = 80% of FREE_MEM
    AUFS_RAM_SIZE=$((8 * free_mem / 10))

    [ "$AUFS_RAM_SIZE" -lt "$MIN_AUFS_RAM" ] && AUFS_RAM_SIZE=$MIN_AUFS_RAM
    mkdir -p $aufs_ram_mp

    mount_tmpfs $aufs_ram_mp $AUFS_RAM_SIZE 'aufs ram' || fatal "Create %s failed" 'aufs tmpfs'
}

mount_aufs() {
    local  aufs_arg  aufs_mp=$1  sqfs_mp=$2  aufs_ram_mp=$3  rootfs_mp=$4

    mkdir -p $aufs_mp

    # Need the cache file because we are using "mount" from the squashfs
    local ld_cache=etc/ld.so.cache
    cp $sqfs_mp/$ld_cache $LIVE_DIR/$ld_cache

    if [ -n "$PERSIST_ROOT" -a -n "$STATIC_ROOT" ]; then
        #. Enable <type> persistence
        msg "Enable %s persistence" "$(pq static rootfs)"
        aufs_arg="$rootfs_mp:$sqfs_mp=ro"
    else
        STATIC_ROOT=
        aufs_arg="$aufs_ram_mp:$sqfs_mp=ro"
    fi

    # Do the actual aufs mount
    vmsg 6 "Mount %s at %s" 'aufs' "$(fq aufs_mp)"

    log_cmd mount -t aufs -o "br:$aufs_arg" $aufs_mp $aufs_mp \
        || fatal "Could not mount %s" aufs

    # Grab what we need from /etc before it gets nuked
    cp -a /etc/mtab $aufs_mp/etc/

    # Temporary top level symlinks to simulate real system
    # These will disappear when we switch_root
    #link_top_dirs $aufs_mp $TOP_DIRS

    # No longer needed, were using the aufs now via symlinks
    rm -f $LIVE_DIR/$ld_cache

    # Always a good idea
    mkdir -p   $aufs_mp/tmp /var/tmp
    chmod 1777 $aufs_mp/tmp /var/tmp

    #set_path "/usr/sbin:/usr/bin:/sbin:/bin:$LIVE_BIN"
}

link_top_dirs() {
    local mp=$1  dir  mp_dir
    shift
    vmsgN 7 'symlink: '
    for dir; do
        mp_dir=$mp/$dir
        [ -d $mp_dir ] || continue
        rm -rf /$dir
        ln -s $mp_dir /$dir
        vmsgN 7 "$white/$dir "
    done
    vmsg 7
}

try_mount() {
    local dev=$1  mp=$2  rw=${3:-$RW_MODE}
    local LABEL UUID TYPE
    eval local $(blkid $dev | sed -r 's/^[^:]+://')
    [ "$TYPE" ] || return 1
    case $TYPE in
            vfat) mount -t vfat -o $rw,umask=000,shortname=winnt  "$dev" "$mp" 2>/dev/null ;;
         iso9660) mount -t iso9660 -o ro                          "$dev" "$mp" 2>/dev/null ;;
            ntfs) ntfs-3g -o umask=000,force,"$rw"                "$dev" "$mp" 2>/dev/null 17>/dev/null || \
                  mount -t ntfs -o umask=000,ro                   "$dev" "$mp" 2>/dev/null ;;
               *) mount -t $TYPE -o "$rw"                         "$dev" "$mp" 2>/dev/null ;;
    esac
    return $?
}

try_mount_old() {
    local dev=$1  mp=$2  rw=${3:-$RW_MODE}

    mount -t vfat -o $rw,umask=000,shortname=winnt    "$dev" "$mp" 2>/dev/null || \
        mount -t iso9660                     -o ro    "$dev" "$mp" 2>/dev/null || \
            ntfs-3g -o umask=000,force,"$rw"          "$dev" "$mp" 2>/dev/null || \
            mount -t ntfs -o umask=000,ro             "$dev" "$mp" 2>/dev/null || \
                mount -t reiserfs            -o "$rw" "$dev" "$mp" 2>/dev/null || \
                    mount -t ext4            -o "$rw" "$dev" "$mp" 2>/dev/null || \
                        mount -t ext3        -o "$rw" "$dev" "$mp" 2>/dev/null || \
                            mount -t ext2    -o "$rw" "$dev" "$mp" 2>/dev/null
    return $?
}

try_file_mount() {
    local file=$1  mp=$2  rw=${3:-$RW_MODE}

    mount -t reiserfs         -o loop,$rw "$file" "$mp"  2>/dev/null || \
        mount -t ext4         -o loop,$rw "$file" "$mp"  2>/dev/null || \
            mount -t ext3     -o loop,$rw "$file" "$mp"  2>/dev/null || \
                mount -t ext2 -o loop,$rw "$file" "$mp"  2>/dev/null
    return $?
}

#------------------------------------------------------------------------------
# Function: mount_tmpfs <mountpoint> <size> <name> <mode>
#------------------------------------------------------------------------------
mount_tmpfs() {
    local mp=$1  size=$2  name=$3  mode=$4
    mkdir -p $mp
    vmsg 6 "Create %s at %s" "${hi_co}$name tmpfs${m_co}" "$(fq $mp) (${num_co}$size ${m_co}MB)"
    log_cmd $LIVE_BIN/mount -t tmpfs -o size=${size}m tmpfs $mp || return 1
    [ "$mode" ] && chmod $mode $mp
    return 0
}

#==============================================================================
# Check Filesystems
#==============================================================================

read_superblock() {
    local dev=$1
    local word_size=$((2**16))
    local addr f1 f2 f3 f4 f5 f6 f7 f8

    while read addr f1 f2 f3 f4 f5 f6 f7 f8; do
        case $addr in
            0000030)
                echo SB_MOUNT_CNT=$f3
                echo SB_MAX_MOUNT_CNT=$f4
                echo SB_MAGIC=$f5
                echo SB_STATE=$f6
                ;;
            0000040)
                echo SB_LASTCHECK=$((    f2 * word_size + f1))
                echo SB_CHECKINTERVAL=$((f4 * word_size + f3))
                ;;
        esac
    done <<DD_Hexdump
$(dd if=$dev bs=1 skip=1024 count=128 2>/dev/null| hexdump -d | sed -r "s/ 0+([0-9])/ \1/g")
DD_Hexdump
}

should_fsck() {
    local dev=$1  sdev=${1##*/}  name=$2  max_count=$MAX_MOUNT_CNT
    [ "$DO_FSCK" ] || return 1

    case ,$DID_FSCK, in
        *,$dev,*) return 1
    esac

    DID_FSCK=$DID_FSCK,$dev

    local SB_MOUNT_CNT SB_MAX_MOUNT_CNT SB_MAGIC SB_STATE SB_LASTCHECK SB_CHECKINTERVAL

    eval $(read_superblock $dev)

    if [ "$SB_MAGIC" != 61267 ]; then
        [ "$FORCE_FSCK" ] \
            && warn 'Cannot check %s filesystem on device %s.  Not an ext2/3/4 filesystem.' \
                "$(pqw $name)" "$(pqw $sdev)"
        return 1
    fi

    local days=$((SB_CHECKINTERVAL /60/60/24))

    vmsg 7 "Check filesystem on %s"                        $(dq $dev)
    vmsg 9 "${green}         Device:$white %s"             $dev
    vmsg 9 "${green}    Mount count:$white %s"             $SB_MOUNT_CNT
    vmsg 9 "${green}Max mount count:$white %s"             $SB_MAX_MOUNT_CNT
    vmsg 9 "${green}   Last checked:$white %s"             "$(date --date=@$SB_LASTCHECK)"
    vmsg 9 "${green}   Magic number:$white 0x%04X"         $SB_MAGIC
    vmsg 9 "${green} Check interval:$white %d$m_co (days)" $days

    [ "$FORCE_FSCK" ] && return 0

    if [ $SB_STATE != 1 ]; then
        warn "%s device %s not cleanly unmounted.  Check forced." "$(pqw $name)" $(pqw $sdev)
        return 0
    fi

    [ "$SB_MAX_MOUNT_CNT" != 65535 ] && max_count=$SB_MAX_MOUNT_CNT

    if [ $SB_MOUNT_CNT -ge $max_count ]; then
        warn "%s device %s has not been checked in %s mounts.  Check forced." \
            "$(pqw $name)" $sdev "$(nq $SB_MOUNT_CNT)"
        return 0
    fi

    [ $SB_CHECKINTERVAL -gt 0 ] || return 1

    [ $((SB_LASTCHECK + SB_CHECKINTERVAL)) -ge $(date +%s) ] || return 1

    warn "%s device %s has not been checked in %s days.  Check forced." \
        $(pqw $name) $(pqw $sdev) "$(nqw $days)"
    return 1
    return 0
}

do_fsck() {
    local err ret output dev=$1  sdev=$(pq ${1##*/})

    local chroot_dir=$SQFS_MP
    system_mount $chroot_dir dev tmp etc

    breakpoint f "Before fsck"

    vmsg 2 "fsck$white $dev"
    output=$(chroot $chroot_dir /sbin/e2fsck -n $dev 2>&1)
    ret=$?
    echo "$output" | tee -a $MY_LOG
    chroot $chroot_dir /sbin/tune2fs -C 1 $dev

    system_umount $chroot_dir

    breakpoint f "After fsck"

    case $ret in
	    0) vmsg 1    "There were no errors on %s"            "$sdev" ; err=0 ;;
	    1) vmsg 1    'Filesystem %s repaired'                "$sdev" ; err=0 ;;
	  2|3) vmsg 1    'Filesystem %s repaired'                "$sdev" ; err=0 ;;
	    4) non_fatal 'Errors on %s left uncorrected'         "$sdev" ; err=1 ;;
	    8) non_fatal '%s operational error on %s'       fsck "$sdev" ; err=1 ;;
	   12) non_fatal '%s interrupted on %s'             fsck "$sdev" ; err=1 ;;
	   32) non_fatal '%s cancelled on %s'               fsck "$sdev" ; err=1 ;;
	    *) non_fatal 'Filesystem %s could not be fixed'      "$sdev" ; err=1 ;;
	esac

    return $err
}

fsck_boot_dev() {
    local dev=$1  mp=$2  sqfs_mp=$3  sq_file=$4  wrap_mp=$5
    local name="boot device"

    local type=$(grep "^$dev " /proc/mounts | cut -d" " -f3)

    if [ -n "$FORCE_FSCK" -a -n "${type##ext[234]}" ]; then
        warn 'Cannot fsck %s device filesystem of type %s' "$(pqw boot)" "$(pqw $type)"
        return
    fi

    should_fsck $dev boot || return

    mount_linuxfs "$sqfs_mp" "$sq_file" "$wrap_mp"

    #breakpoint f "After mounting linuxfs before fsck"

    do_fsck $dev

    # Always remount everything after fsck of boot device.  Don't want any
    # nasty surprises if we only do it when we need to.
    # We don't need no stinkin' reboots
    set_path $LIVE_BIN
    umount $sqfs_mp
    mountpoint -q $wrap_mp && umount $wrap_mp
    umount $mp

    # Now mount the boot device again so no one knows we were here
    try_mount $dev $mp || fatal "Could not remount boot device %s" "$(pqh $dev)"
}

#==============================================================================
#   Misc Functions
#==============================================================================

set_path() {
    PATH=$1
    hash -r
}

should_break_at() {
    local bp=$1
    case ,$BREAK_POINTS, in
        *,$bp,*) return 0 ;;
          *,A,*) return 0 ;;
          *,a,*)          ;;
              *) return 1 ;;
    esac
    case $bp in
        [e1-9]) return 0 ;;
             *) return 1 ;;
    esac
}

custom_code() {
    local file=$1  desc=$2

    [ "${#file}" -eq 1 ] && file=$CUSTOM_DIR/$DISTRO/$file.sh

    [ -r $file ] || return

    if $LIVE_BIN/sh -n $file; then
        [ "$desc" ] && vmsg 7 'Run custom code %s: %s' "$white$desc$m_co" "$(fq $file)"
        . $file
    else
        non_fatal 'Errors found in custom code: %s.  Skipping' "$(pqh $file)"
    fi
}

breakpoint() {
    local bp=$1  desc=$2

    custom_code "$bp" "$desc"

    if ! should_break_at $bp; then

        if [ "$TEST_ERRORS" ]; then
            msg "normal message one"
            echo "test error" >&2
            msg "normal message two"
        fi

        [ "$DB_PLUS" ] || return
        vmsg 9 "$green@bp$cyan[$num_co$bp$m_co]$hi_co $(get_seconds)s$m_co: $desc"
        [ "$TEST_FATAL" ] && [ "$TEST_FATAL" = "$bp" ] && non_fatal "Test at bp=$bp $desc"
        return
    fi

    echo "$green$tbar$nc_co"
    echo "$green==>$cyan limited shell @ breakpoint [$num_co$bp$cyan]$white $desc"
    echo "$green    Use the$white exit$green command or hit$white Ctrl-d$green to continue"

    local bp_time_1=$(get_time)
    env PS1="${green}bp $red$bp$cyan>$nc_co " BP=$bp PATH=$LIVE_BIN:$PATH \
        setsid cttyhack sh 17>/dev/null
    local bp_time_2=$(get_time)
    time_0=$((time_0 + bp_time_2 - bp_time_1))
    echo
}

db_msg() { vmsg 5 "${green}db+:$hi_co $@" ;}
err()    { vmsg 1 "$err_co$@"             ;}
msg()    { vmsg 5 "$@"                    ;}
msgN()   { vmsgN 5 "$@"                   ;}
msg_nc() { vmsg 5 "$nc_co$@"              ;}
warn()   { vmsg 3 "$warn_co$@"            ;}

bq()     { echo "$yellow$*$m_co"          ;}
cq()     { echo "$cheat_co$*$m_co"        ;}
cqw()    { echo "$cheat_co$*$warn_co"     ;}
cqe()    { echo "$cheat_co$*$err_co"      ;}
dq()     { echo "$dev_co$*$m_co"          ;}
dqe()    { echo "$dev_co$*$err_co"        ;}
fq()     { echo "$from_co$*$m_co"         ;}
fqe()    { echo "$from_co$*$err_co"       ;}
mpq()    { echo "$mp_co$*$m_co"           ;}
nq()     { echo "$num_co$*$m_co"          ;}
nqw()    { echo "$num_co$*$warn_co"       ;}
pq()     { echo "$hi_co$*$m_co"           ;}
pqe()    { echo "$bold_co$*$err_co"       ;}
pqw()    { echo "$hi_co$*$warn_co"        ;}
pqh()    { echo "$m_co$*$hi_co"           ;}
hq()     { echo "$hi_co$*$m_co"           ;}

get_time() { cut -d" " -f22 /proc/self/stat ;}

get_seconds() {
    local dt=${1:-$(get_time)}
    printf "%02d" $dt | sed -r 's/(..)$/.\1/'
}

bogo_meter() {
    local width=${1:-$SCREEN_WIDTH} delay=60  dot=.
    #echo "width: $width"
    local cnt=$(( width * 80 / 100 ))
    #echo "  cnt: $cnt"
    local sleep=$(( 1000000 * delay / cnt ))
    #echo "sleep: $sleep"
    while true; do
        for s in $(seq 1 $cnt); do
            echo -n "$dot"
            usleep $sleep
        done
        echo
    done
}

time_cmd() {
    local t0=$(get_time)
    (bogo_meter)&
    local pid=$!
    "$@"
    local ret=$?
    local t1=$(get_time)
    local secs=$(get_seconds $((t1 - t0)))
    kill -9 $pid
    echo
    vmsg 5 "command %s took %s seconds" "$(pq $*)" "$(nq $secs)"
    return $ret
}

vmsg_old() {
    local msg nflag  level=$1; shift

    [ "$1" = "-n" ] && nflag=true && shift
    local fmt=$1; shift

    if [ "$nflag" ]; then
        msg="$(printf "$m_co$fmt$nc_co" "$@")"
    else
        msg="$(printf "$m_co$fmt$nc_co" "$@")\n"
    fi

    [ "$level" -le "$VERBOSE" ] && printf "$msg"
    echo -ne "$msg" >> $MY_LOG
    #LOG="$LOG$msg"

    return 0
}

vmsg() {
    local level=$1  fmt=$2
    shift 2

    msg=$(printf "$m_co$fmt$nc_co" "$@")

    [ "$level" -le "$VERBOSE" ] && printf "$msg\n"
    echo -e "$msg" >> $MY_LOG
    return 0
}

vmsgN() {
    local level=$1  fmt=$2
    shift 2

    msg=$(printf "$m_co$fmt$nc_co" "$@")

    [ "$level" -le "$VERBOSE" ] && printf "$msg"
    echo -ne "$msg" >> $MY_LOG
    return 0
}

vmsg_if() {
    local level=$1; shift
    [ "$VERBOSE" -ge "$level" ] || return
    vmsg $level "$@"
}

vmsg_nc() {
    local level=$1; shift
    vmsg $level "$nc_co$@"
}

heading() {
    vmsg 6 $head_co$tbar
    #. Begin [doing some sub process]
    vmsgN 3 "$head_co%s " "Begin"
    vmsg 3 "$@"
}

# This is cheesy and fragile. We are using output in stderr to indicate
# an error condition.  The upside is we can log the error messages.
log_cmd()
{
    local err_msg=$("$@" &>/dev/null)
    if [ -n "$err_msg" ]; then
        vmsg 1 "$hi_co$*"
        err "$err_msg"
        return 1
    else
        vmsg_nc 7 "$*"
    fi
    return 0
}

_error() {
    local type=$1  cmsg1=$2  cmsg2=$3  msg=$4
    shift 3

    local match="$(echo $NO_ERROR | sed 's/_/ /g')"
    if [ "$NO_ERROR" -a -z ${msg##$match*} ]; then
        msg "Skip Error: %s" "$(bq $msg)"
        return
    fi

    if [ "$type" ]; then
        warn
        warn $hbar
        err "$type"
        [ "$1" ] && msg "${hi_co}$1"
        shift
        for arg; do
            msg "${hi_co}$arg"
        done
        warn $hbar
        err
    fi

    breakpoint e "On possibly fatal error"

    local prompt="${green}Select ${yellow}$cmsg1 p$green or$yellow r$green then hit <enter>"

    local fmt="    $yellow%s$cyan =$white %s$nc_co\n"
    local reply
    while [ true ]; do
        echo $m_co$tbar$nc_co

        [ "$cmsg1" ] && printf "$fmt" "$cmsg1" "$cmsg2"
        printf "$fmt" p "power off"
        printf "$fmt" r "reboot"

        echo $m_co$tbar$nc_co
        echo -n "$prompt$nc_co "
        read reply
        case $reply in
            p*|P*)
                echo "power off" " ..."
                safe_shutdown poweroff;;

            r*|R*)
                echo "reboot"  " ..."
                safe_shutdown reboot;;

             c*|C*)
                 [ "$cmsg1" ] && return;;
        esac
        printf "\n${m_co} %s: >>$yellow$reply$m_co<<. %s:$nc_co\n" \
            "Unknown command" "Please try again"
    done
}

move_mountpoints() {
    local dir mp old aufs_live=/live/aufs$FINAL_DIR

    [ -d $aufs_live ] || return

    for dir in $(ls $aufs_live); do
        [ "$dir" = aufs ] && continue
        mp=$aufs_live/$dir
        mountpoint -q $mp || continue
        old=/live/$dir
        mkdir -p $old
        # echo mount --move $mp $old
        mount --move $mp $old
    done
}

mountpoint_list() {
    local dev mp other ret=1

    while read dev mp other; do
        case $mp in /|/dev|/dev/*|/proc|/sys) continue;; esac
        echo -n "$mp "
        ret=0
    done << Read_Mounts
$(tac /proc/mounts)
Read_Mounts
    return $ret
}

final_umount() {
    local mp list i
    move_mountpoints

    for i in $(seq 1 4); do
        list=$(mountpoint_list) || return 0
        for mp in $list; do
            umount $mp
        done
    done
    list=$(mountpoint_list) || return 0
    err "Unable to unmount %s" "$(pq $list)"
    return 1
}

safe_shutdown() {
    local cmd=$1  ask=$2

    set_path $LIVE_BIN
    #exec < /dev/console > /dev/console

    final_umount && vmsg 1 "Unmount successful"
    breakpoint u "final umount"
    if [ "$ask" ]; then
        vmsgN 1 "Press <Enter> to %s" "$(hq $cmd)"
        read x
    fi
    vmsg -1 "Will now %s the system" "$(hq $cmd)"
    #sleep 1
    exec $cmd -f -n
}

_fatal()     { _error "Fatal Error"     ""  ""          "$@" ;}
_non_fatal() { _error "Non-Fatal Error" "c" "continue"  "$@" ;}
fatal()      { _fatal     "$(printf "$@")"                   ;}
non_fatal()  { _non_fatal "$(printf "$@")"                   ;}

YES_no() {
    local ans title=$(printf "$m_co$@")
    local yes=$(cq "yes")  no=$(cq "no")  y_lett=$(bq y) n_lett=$(bq n)

    local err_msg=$(printf "You must answer %s or %s. Please try again" $(pqe y) $(pqe n))
    echo
    while true; do
        echo -e "$title?"
        printf "${m_co}$y_lett=$yes. $n_lett=$no. %s $y_lett=$yes\n" "The default is"
        echo -n "$green>$nc_co "

        read ans
        case x$ans in
            x[Yy]*) return 0;;
            x[Nn]*) return 1;;
        esac

        [ -z "$ans" ] && return 0
        printf "$err_co%s$nc_co\n" "$err_msg"
    done
}

my_select() {
    local title=$1  var=$2  width=${3:-0}  default=$4
    shift 4

    local data display lab cnt=0
    for lab; do
        cnt=$((cnt+1))
        data="${data}$cnt:$lab\n"
        [ $cnt = "$default" ] && lab=$(printf "%${width}s (%s)" "$lab" "$(cq "default")")
        display="${display}$(printf "%2d) %${width}s" $cnt "$lab")\n"
    done

    local def_prompt=$(printf "Press <%s> for the default selection" "$(cq "enter")")

    local val input err_msg
    while [ -z "$val" ]; do

        printf "$bold_co%s$nc_co\n" "$title"
        printf "$display" | sed -r -e "s/(^|\t)( ?[0-9]+)(\))/\t$green\2$white\3$cyan/g" -e "s/$/$nc_co/"
        [ "$err_msg" ] && printf "$err_co%s$nc_co\n" "$err_msg"
        [ "$default" ] && printf "$m_co%s$nc_co\n" "$def_prompt"
        echo -n "$green>$nc_co "

        read input
        err_msg=
        [ -z "$input" -a -n "$default" ] && input=$default

        if ! echo "$input" | grep -q "^[0-9]\+$"; then
            err_msg="You must enter a number"
            [ "$default" ] && err_msg="You must enter a number or press <enter>"
            continue
        fi

        val=$(echo -e "$data" | sed -n "s/^$input://p")

        if [ -z "$val" ]; then
            err_msg=$(printf "The number <%s> is out of range" "$(pqe $input)")
            continue
        fi

        eval $var=\$val
        break
    done
}

sync_fs() {
    sync
}

label_to_dev() { any_to_dev 'LABEL' "$@"  ;}
uuid_to_dev()  { any_to_dev 'UUID'  "$@"  ;}

# This is like findfs but this returns a list if there is more than one device
any_to_dev() {

    local field="$1=\"$2\"" devices
    local dev f1 f2 other
    while read dev f1 f2 other; do
        [ "$f1" = "$field" -o "$f2" = "$field" ] && devices="$devices$dev "
    done <<EOT
$(blkid)
EOT
    echo "$devices" | sed 's/://g' | sed 's/ $//'
}

cleanse_dev() {
    case $1 in
        /dev/*)  [ -b "$1"      ] && echo "$1";;
         dev/*)  [ -b "/$1"     ] && echo "/$1";;
            /*)  [ -b "/dev$1"  ] && echo "/dev$1";;
             *)  [ -b "/dev/$1" ] && echo "/dev/$1";;
    esac
}

label_error() {
    local find_type=$1  param=$1$2 name=$2  value=$3  field=$(echo $2 | tr 'a-z' 'A-Z')
    warn "$hbar"
    err "Fatal Error"
    err "No device with %s was found" "$(cqe $name=$value)"

    vmsg_nc 3 "Valid %s" "${name}s:"
    local line val LABEL TYPE UUID
    while read line; do
        eval $field=
        eval local "$line"
        eval val=\$$field
        [ "$val" ] && echo "$white  $param=$val$nc_co"
    done <<EOT
$(blkid | sed 's/^[^:]*://')
EOT
    warn "$hbar"
    case $from_type in
        persist) _error "" c "continue" ;;
              *) _error                 ;;
    esac
}

general_device_error() {
    #msg "gde($*)"
    case $2 in
        uuid|label) label_error  "$@" ;;
              name) device_error "$@" ;;
    esac
}

device_error() {
    local find_type=$1  type=$2  value=$3
    local valid_devs=$(echo $(most_block_devices) | sed "s/^/$white    /");
    if [ "$find_type" = 'persist' ]; then
        _non_fatal "$(printf "Could not find device %s" "$(pqh $type)")" "Valid devices": "$valid_devs"
    else
        _fatal "$(printf "Could not find device %s" "$(pqh $type)")" "Valid devices": "$valid_devs"
    fi
}

cp_file() {
    local src=$1  name=$2  dest=$3  file=$1/$2
    mkdir -p $dest
    echo -n $hi_co
    local tar=$LIVE_BIN/tar
    local progress=$LIVE_BIN/pipe_progress

    if [ ! -d "$src" ]; then
        err 'Source directory %s does not exist' $(pqe $src)
        return 2
    fi

    if [ ! -f "$file" ]; then
        err 'Source file %s does not exist' $(pqe $file)
        return 3
    fi

    $tar -C "$src" -hcf - "$name" | $progress | $tar -C "$dest" -xpf -
    local ret=$?
    echo -n $nc_co
    vmsg 8 "cp_file returned:$num_co $ret"
    return $ret
}

#------------------------------------------------------------------------------
# Function: cp_rm_dest <src> <dest>
#
# Emulate cp --remove-destination in busybox
#------------------------------------------------------------------------------
cp_rm_dest() {
    local src=$1 dest=$2
    rm -f "$dest"
    cp "$src" "$dest"

}

#------------------------------------------------------------------------------
# Function: cp_dir <sorc> <dest>
#------------------------------------------------------------------------------
cp_dir() {
    mkdir -p "$2"
    echo -n $hi_co
    local tar=$LIVE_BIN/tar
    local progress=$LIVE_BIN/pipe_progress
    $tar -C "$1" -cf - . | $progress | $tar -C "$2" -xpf -
    local ret=$?
    echo -n $nc_co
    return $ret
}

all_space()      { $LIVE_BIN/df -m "$1" | awk '{size=$2}END{print size}' ;}
used_space()     { $LIVE_BIN/df -m "$1" | awk '{size=$3}END{print size}' ;}
free_space()     { $LIVE_BIN/df -m "$1" | awk '{size=$4}END{print size}' ;}
get_mountpoint() { grep "^$1 " /proc/mounts | cut -d" " -f2              ;}

dir_has_param() {
    local dir=$1  want_param=$2

    [ -d "$dir" ] || return 1

    local dev=$(df $dir | tail -n1 | cut -d" " -f1)
    local params=$(grep "^$dev " /proc/mounts | cut -d" " -f4)
    case ,$params, in
        *,$want_param,*) return 0;;
    esac
    return 1
}

#------------------------------------------------------------------------------
# Function: get_vid <file>
#------------------------------------------------------------------------------
get_vid()   { [ -r "$1" ] && grep ^=== $1 | tail -n 1   ;}
vid_error() { VID_ERROR=$(printf "$@"); non_fatal "$@"  ;}

#------------------------------------------------------------------------------
# Function: check_vid <sqfs_vid> <mp> <fname>
#------------------------------------------------------------------------------

check_vid() {
    local sqfs_vid=$1  mp=$2  fname=$3  vid_file="$2$VID_DIR/$3.ver"
    breakpoint v "before check VID"

    local rootfs_vid=$(get_vid $vid_file)

    if [ -n "$sqfs_vid" -a -n "$rootfs_vid" ]; then

        if [ "$rootfs_vid" = "$sqfs_vid" ]; then
            vmsg 6 'Matching %s found in %s' "$VID_NAME" "$(fq $vid_file)"
            return 0
        else
            local err=$(printf "%s mismatch between %s and %s" "$VID_NAME" linuxfs rootfs)
            VID_ERR=$err
            #. <type> mismatch
            _non_fatal "$err" "linuxfs: $sqfs_vid" " rootfs: $vid"
            return 1
        fi

    elif [ "$sqfs_vid" ]; then

        # Pass test and create new rootfs version file if rootfs is empty
        if ! ls $mp | egrep -q 'etc|bin|lib|var|usr'; then
            msg "Copy %s to empty %s" "$LINUXFS_NAME $VID_NAME" rootfs
            log_cmd mkdir -p "$mp$VID_DIR"      || return 1
            log_cmd cp $SQFS_VID_FILE $vid_file || return 2
            sync_fs
            return 0

        elif ! [ -f "$vid_file" ]; then
            #. <type> file not found <name>
            vid_error "%s file not found %s" "$VID_NAME" "$vid_file"
            return 1

        else
            vid_error "No %s found in file %s" "$VID_NAME" "$vid_file"
            return 1
        fi

    elif [ "$rootfs_vid" ]; then
        vid_error "No %s found but there is a %s" "$LINUXFS_NAME $VID_NAME" "rootfs $VID_NAME"
        return 1
    else
        vmsg 6 "No %s or %s found" "$LINUXFS_NAME $VID_NAME" "rootfs $VID_NAME"
        return 0
    fi
}

#------------------------------------------------------------------------------
# Function: check_md5 <dir>
#
# Checks the md5 sum of all files in <dir> that have a <name>.md5 file.
#------------------------------------------------------------------------------
check_md5()
{
    local dir=$1 passed="passed"  failed="failed"
    [ ! -d "$dir" ] && dir=$(echo $1 | sed 's|\(.*\)/.*|\1|')
    dir=$(echo $dir | sed 's|/$||')
    if ! [ -d "$dir" ]; then
        msg $tbar
        err "Directory %s does not exist" "$(fqe $1)"
        err "Can't perform %s check" md5
        msg $tbar
        return 0
    fi

    local fcnt=0

    vmsg 2 $tbar
    vmsg_nc 1 "Check md5 of files in %s directory. Please be patient ..." "$(fq $dir)"

    local file fname md5_file file_md5 true_md5 error
    for fname in $(ls $dir); do
        file=$dir/$fname
        local size=$(du -sm $file | cut -f1)
        md5_file="$file.md5"
        [ -f "$md5_file" -a -f "$file" ] || continue

        local size_str="$nc_co($num_co$size$nc_co M)"
        # vmsg 1
        vmsg 1 $tbar
        vmsg_nc 1 "           file: %s" "${nc_co}$fname $size_str"
        fcnt=$(( fcnt + 1 ))
        true_md5="$(head -n 1 $md5_file | cut -d" " -f1)"
        file_md5="$(cat $file | pipe_progress | md5sum | cut -d" " -f1)"

        if [ "$file_md5" == "$true_md5" ]; then
            vmsg_nc 1 "         result: %s" "${ok_co}$passed"
        else
            vmsg_nc 1 "         result: %s" "${err_co}$failed"
            error=true
        fi

        vmsg 6 "         wanted: %s" "$num_co$true_md5"
        vmsg 6 "            got: %s" "$num_co$file_md5"
    done

    vmsg 1
    if [ "$fcnt" = 0 ]; then
        err "No md5 checksums were found in %s. Can't do any md5 checks." "$(fqe $dir)"
    elif [ "$error" ]; then
        non_fatal "At least one md5 checksum did not match"
    elif [ "$fcnt" = 1 ]; then
        vmsg 1 "Success!  The file passed"
    else
        #. Success! All <count> file(s) passed
        vmsg 1 "Success!  All %s files passed" $(nq $fcnt)
    fi
    vmsg 2 $tbar
}

do_delay() {
    local cnt=$1; shift
    [ -z "$cnt" -o "$cnt" = "0" ] && return
    [ $# -gt 0 ] && msg "$@"
    while [ "$cnt" -gt "0" ]; do
        msgN "$hi_co$cnt "
        cnt=$((cnt - 1))
        sleep 1
    done
    msg
}

set_colors() {
    local noco=$1  loco=$2

    [ "$noco" ] && return

    local e=$(printf "\e")
     black="$e[0;30m";    blue="$e[0;34m";    green="$e[0;32m";    cyan="$e[0;36m";
       red="$e[0;31m";  purple="$e[0;35m";    brown="$e[0;33m"; lt_gray="$e[0;37m";
   dk_gray="$e[1;30m"; lt_blue="$e[1;34m"; lt_green="$e[1;32m"; lt_cyan="$e[1;36m";
    lt_red="$e[1;31m"; magenta="$e[1;35m";   yellow="$e[1;33m";   white="$e[1;37m";
     nc_co="$e[0m";

    cheat_co=$white;      err_co=$red;       hi_co=$white;
      cmd_co=$white;     from_co=$lt_green;  mp_co=$magenta;   num_co=$magenta;
      dev_co=$magenta;   head_co=$yellow;     m_co=$lt_cyan;    ok_co=$lt_green;
       to_co=$lt_green;  warn_co=$yellow;  bold_co=$yellow;

    [ "$loco" ] || return

    from_co=$brown
      hi_co=$white
       m_co=$nc_co
     num_co=$white
}

next_device() {
    local base=$(echo $1 | sed 's/[0-9]*$//')
    local num=$(echo $1 | sed 's/^[^0-9]*//')
    while [ "$num" -lt "20" ]; do
        num=$((num + 1))
        device=$base$num
        [ -b "$device" ] || continue
        echo $device
        return 0
    done
    return 1
}

# FIXME: converted retry to retry_time.  Need to test
find_crypt_device() {
    local retry_time=$1  try=-1
    local start_t=$(get_time) current_t=0  final_try
    local dt dt_secs loop_t1 usleep dt_secs
    local goal_t=$(( start_t + retry_time * 100))
    while [ -z "$final_try" ]; do
        try=$((try + 1))
        #-- delay every time but the first
        if ! [ "$try" = "0" ]; then
            [ "$try" = "1" ] && msgN "%s " "retrying"

            current_t=$(get_time)
            dt=$((current_t - loop_t1))
            usleep=$(( ($RETRY_DELAY - dt ) * 10000))

            [ $current_t -gt $goal_t ] && final_try=true

            [ $usleep -gt 0 ] && usleep $usleep

            msgN "."

        fi
        loop_t1=$(get_time)
        find_device crypt "$try" "$final_try" "$CRYPT_ID" || return
        [ "$DEVICE_LIST" ] && return 0
    done
    return 1
}

will_remaster() {
    [ -n "$NO_REMASTER" -o "$ROLLBACK" ] && return 1

    local sqfile_path=${1:-$SQFILE_MP/$SQFILE_PATH}
    local sqfile=$sqfile_path/$SQFILE_NAME
    local old_file=$sqfile.old new_file=$sqfile.new bad_file=$sqfile.bad
    [ -e $old_file -o -e $bad_file ] && return 1
    [ -e $new_file ]
    return $?
}

#------------------------------------------------------------------------------
# Function: do_remaster <dir>
#
# If <dir>/linuxfs.new exists we move:
#       linuxfs     -->  linuxfs.old
#       linuxfs.new -->  linuxfs
#
# If the "rollback" cheatcode is used, we instead move:
#       linuxfs     -->  linuxfs.bad
#       linuxfs.old -->  linuxfs
#------------------------------------------------------------------------------
do_remaster() {
    [ "$NO_REMASTER" ] && return 0
    local sqfile_path=$1
    local sqfile="$sqfile_path/$SQFILE_NAME"
    local old_file="$sqfile.old" new_file="$sqfile.new" bad_file="$sqfile.bad"


    if [ "$ROLLBACK" ]; then
        heading 'remaster %s' "$(cq rollback)"

        if ! [ -f "$old_file" ]; then
            err -n "The boot parameter %s was given but no %s was found" \
                "$(cqe rollback)" "$(fqe $SQFILE_NAME.old)"

            do_delay 10 "Wait %s seconds" "${num_co}10$m_co"
            return 1
        fi
        msg $tbar
        warn "Roll back file %s to %s" "$SQFILE_NAME.old" "$SQFILE_NAME"
        msg $tbar

        local file full
        for file in $SQFILE_NAME $MAKE_OLD; do
            full=$sqfile_path/$file
            [ -e $full.bad ] && log_cmd mv -f $full.bad $full.bak
            [ -e $full     ] && log_cmd mv -f $full     $full.bad
            [ -e $full.old ] && log_cmd mv -f $full.old $full
        done

        DID_ROLLBACK=true
        sync_fs
        sleep 2
        return 0
    fi

    [ -e $new_file ] || return 0

    heading 'remaster'

    if [ -e $old_file -o -e $bad_file ]; then
        warn  "$m_co$tbar"
        warn  "Will not remaster"
        warn  "In directory %s one or more of these files already exist"  "$sqfile_path"
        warn  "    $SQFILE_NAME.old"
        warn  "    $SQFILE_NAME.bad"
        warn
        warn  "Run the %s program to fix this problem" 'remaster-live'
        warn  "$m_co$tbar"

        non_fatal
        return 2
    fi
    msg $tbar
    warn "Remaster the file %s to %s" "$SQFILE_NAME.new" "$SQFILE_NAME"
    msg $tbar

    local file full
    for file in $SQFILE_NAME $MAKE_OLD; do
        full=$sqfile_path/$file
        [ -e $full     ] && log_cmd mv -f $full $full.old
        [ -e $full.new ] && log_cmd mv -f $full.new $full
    done

    DID_REMASTER=true
    sync_fs
    sleep 2
    return 0
}

most_block_devices() { find /dev -type b | egrep -v "/ram|/loop|/fd" ; }

#------------------------------------------------------------------------------
# Function: copy_to_ram
#
# Copies the linuxfs file (and a few other files) to RAM
#------------------------------------------------------------------------------
copy_to_ram() {
    local toram_mp=$1

    if _copy_to_ram "$@"; then

        SQFILE_MP=$toram_mp
        SQFILE_DIR=$toram_mp/$SQFILE_PATH
        SQFILE_FULL=$toram_mp/$SQFILE_FILE
        DEFAULT_DIR=$SQFILE_DIR
    else
        breakpoint ce "After toram copy file error"
        mountpoint -q $toram_mp && log_cmd umount $toram_mp
        [ -d $toram_mp ]        && rmdir $toram_mp
    fi
}

_copy_to_ram() {
    local toram_mp=$1  err_toram=$(cqe toram)

    heading "copy %s file to RAM" "$(fq $LINUXFS_NAME)"
    local real_sq_file=$(readlink -f $SQFILE_FULL)
    local sq_size_k=$(du -sk $real_sq_file | cut -f 1)

    local format="%15s: %10d k"
    local format2="%s: %10d k"
    vmsg 8 "$format" "$LINUXFS_NAME" $sq_size_k

    local extra ex_full size_k
    for extra in $EXTRA_FILES; do
        ex_full="$(readlink -f $SQFILE_DIR/$extra)"
        [ -e "$ex_full" ] || continue
        size_k="$(du -sk $ex_full | cut -f 1)"
        sq_size_k=$((sq_size_k + size_k))
        vmsg 8 "$format" $extra $size_k
        #. Total [RAM needed]
        vmsg 8 "$format2" "          Total"  $sq_size_k
    done

    # Extra space here does not waste ram
    local sq_size_m=$((sq_size_k/1000 + 10))

    local ram_needed=$((sq_size_m + MIN_SYS_RAM));

    if [ "$sq_size_m" -gt "$FREE_MEM" ]; then
        err "Not enough RAM available to do %s" $err_toram
        #. Have <size> RAM, needed <size>
        err "have %s RAM, needed %s" "${num_co}$FREE_MEM ${m_co}M${err_co}" \
            "${num_co}$sq_size_m ${m_co}M"
        return 1
    fi
    if ! mount_tmpfs $toram_mp $sq_size_m toram; then
        err "Unable to mount %s.  Will not do %s" tmpfs $err_toram
        return 2
    fi

    local orig=$SQFILE_DIR
    local dest="$toram_mp/$SQFILE_PATH"

    mkdir -p "$dest"

    vmsg 3 "Will copy files from %s to %s. Please be patient ..." \
        "$(dq $orig)" "$(dq $dest)"

    for extra in $EXTRA_FILES; do
        local full=$(readlink -f $SQFILE_DIR/$extra)
        [ -e "$full" ] && cp -a $full $dest
    done
    [ -e $SQFILE_FULL.md5 ] && cp $SQFILE_FULL.md5 $dest

    if ! cp_file $orig $SQFILE_NAME $dest 2>&1; then
        err "Copy failed.  Cannot do %s" $err_toram
        return 3
    fi

    if ! [ -f "$dest/$SQFILE_NAME" ]; then
        err "The destination file is missing. The %s has failed." $err_toram
        return 4
    fi

    # Rely on file size in bytes to check for errors
    local orig_bytes=$(stat -c "%s" $real_sq_file)
    local dest_bytes=$(stat -c "%s" $dest/$SQFILE_NAME)

    if [ "$orig_bytes" -ne "$dest_bytes" ]; then
        err "Copy was incomplete. The %s failed" $err_toram
        format="%s: ${num_co}%12d${m_co} bytes"
        vmsg 1 "                 Size of original" $orig_bytes
        vmsg 1 "                     Size of copy" $dest_bytes
        vmsg_nc 1 "$(df -m | grep $toram_mp)"
        return 5
    fi

    msg "${ok_co}%s" "Copy to RAM succeeded"

    # Reduce FREE_MEM by size of tmpfs
    FREE_MEM=$((FREE_MEM - sq_size_m))

    vmsg 6 '    persistence device: %s' $(pq $PERSIST_DEVICE)
    vmsg 6 '           boot device: %s' $(pq $SQFILE_DEV)

    if ! [ "$PERSIST_DEVICE" -a "$PERSIST_DEVICE" = "$SQFILE_DEV" ]; then
        # remount ro to be on the safe side
        log_cmd mount -o remount,ro $toram_mp
        DELAYED_UMOUNT=$SQFILE_MP
    fi

    DID_TORAM=true
    return 0
}

#------------------------------------------------------------------------------
# Function: prepare_persistence
#
# Parse the persist= bootcode but first set defaults.
#------------------------------------------------------------------------------
prepare_persistence() {
    local param persist_files

    # pdev= and pdir= etc enable persistence even with no persist= bootcode.
    if [ "$PERSIST_ID" ]; then
        : ${PERSIST:=root,home}
    else
        # if we are on a read-only device and persist was set then set default
        # persist label if persist device was not explicitly given
        if [ -z "$REMASTERABLE" -a -n "$PERSIST" ]; then
            AUTO_PERSIST="$DISTRO-Persist"
            warn "Persistence requested on a read-only boot device"
            warn "Will search for a persistence device with the label %s" "$(pqw $AUTO_PERSIST)"
            PERSIST_ID=label="$AUTO_PERSIST"
        fi
    fi

    PERSIST_PATH=${PERSIST_PATH:-$DEFAULT_PERSIST_PATH}

    [ "$PERSIST" ] && ! echo $PERSIST | egrep -q 'home|root|r(,|!|$)|h(,|!|$)' && PERSIST="$PERSIST,home,root"

    will_remaster && WILL_REMASTER=true

    local rootfs_file=rootfs
    [ "$WILL_REMASTER" ] && rootfs_file=rootfs.new

    #----- Parse persist= ---------------------------------------------------------

    for param in $(echo "$PERSIST" | sed 's/,/ /g'); do

        case $param in
            s|static)
                STATIC_ROOT=true;;
        esac

        # You can't always get what you want ...
        case $param in
            home|home!|h|h!)
                persist_files="$PERSIST_PATH/homefs $persist_files"
                persist_files="$PERSIST_PATH/homefs.new $persist_files"
                WANT_HOMEFS=true ;;

            root|root!|r|r!)
                persist_files="$PERSIST_PATH/$rootfs_file $persist_files"
                WANT_ROOTFS=true ;;

            auto|a)
                AUTO_MAKE_FS=true;;

            usb|hd)
                FROM_PERSIST="$FROM_PERSIST,$param" ;;

            static|s) ;;

            *)
                warn
                warn "Invalid %s values(s) %s"  $(cqw persist) "$(cqw $param)"
                warn "Valid values: %s" "$(cqw auto home home! root root! static usb hd a h h! r r! s)" ;;
        esac

        # And if you try sometime ...
        case $param in
            home!|h!)
                NEED_HOMEFS=true;;
            root!|r!)
                NEED_ROOTFS=true;;
        esac
    done
    PERSIST_FILES=$persist_files

}

create_persist_files() {

    dir_has_param "$SQFILE_DIR" rw || return

    if [ "$NEED_ROOTFS" ]; then

        # Default size for rootfs.new is size of rootfs
        local default_size rootfs_file=rootfs
        if [ "$WILL_REMASTER" ]; then
            default_size=$(stat -c %s $SQFILE_DIR/rootfs 2>/dev/null)
            msg 'default size: %s' "$(nq $default_size)"
            [ "$default_size" ] && default_size=$((default_size/1024/1024))
            rootfs_file=rootfs.new
        fi

        persist_makefs root $SQFILE_DIR $rootfs_file NEED_ROOTFS $default_size
        persist_makefs home $SQFILE_DIR homefs       NEED_HOMEFS

    elif [ "$NEED_HOMEFS" ]; then
        persist_makefs home $SQFILE_DIR homefs       NEED_HOMEFS
    fi

}

persist_makefs() {
    local type=$1  dir=$2  file=$3  needed_var=$4  orig_def_size=$5  full_file=$2/$3

    [ -e $full_file ] && return

    eval local needed=\$$needed_var
    unset $needed_var

    local free=$(free_space $dir)
    local avail=$((free - MKFS_FREE_MARGIN))

    vmsg 6 '     Free space: %s Meg' $(nq $free)
    vmsg 6 'Available space: %s Meg' $(nq $avail)

    [ "$orig_def_size" ] && [ $orig_def_size -gt $avail ] \
        && warn "Not enough room on Live device to create %s file of size %s Meg" \
            $(fq $file) $(nq $orig_def_size)

    local default_size=$(default_makefs_size $avail ${file}_SIZE_PARAM $orig_def_size)

    vmsg 6 'Default size: %s' $(nq $default_size)

    : ${default_size:=-1}

    # Create a menu of sizes.  Include the default size
    local size sizes default_cnt cnt=1
    for size in $MKFS_SIZES; do
        if [ -z "$default_cnt" -a $default_size -gt 0 -a $size -ge $default_size ]; then
            sizes="$sizes $default_size"
            default_cnt=$cnt
        fi
        cnt=$((cnt + 1))
        [ $size -gt $avail ] && break
        [ $size -eq $default_size ] && continue
        sizes="$sizes $size"
    done

    # Include default size at end of menu if needed
    if [ -z "$default_cnt" -a $default_size -gt 0 ]; then
        sizes="$sizes $default_size"
        default_cnt=$cnt
    fi

    # FIXME
    [ "$sizes" ] || return

   # Include all available in menu if it is appropriate
    local max=$(echo "$sizes" | sed 's/.* //')
    [ $max -lt $avail -a $avail -lt $MAX_MKFS_SIZE ] && sizes="$sizes $avail"

    local fs_type fs_size auto_mode create_mode quit=$(printf "quit")
    #[ "$needed" ] && quit=

    vmsg 1 "%s persistence was requested but no %s file was found" $(cq $type) $(fq $file)

    heading "create %s persistence file" "$(fq $file)"
    vmsg 1 "Default size: %s  Default type: %s" $(nq $default_size) $(pq ext3)
    warn "Warning: this operation can take a few minutes"

    if [ "$AUTO_MAKE_FS" ]; then
        auto_mode=true
    else
        local title=$(printf "Create %s file, manually or automatically" $(fq $file))
        my_select "$title" create_mode 0 1 "create automatically" "create custom" "$quit"
        case $create_mode in
                            "quit") return ;;
            "create automatically") auto_mode=true;;
        esac
    fi

    if [ "$auto_mode" ]; then
       fs_type=ext3
        fs_size=$default_size

    else
        local title=$(printf "Please select size of %s file" $(pqw $file))

        echo
        vmsg 1 "There is %s Meg available on the device" $(nq $avail)
        my_select "$title" fs_size 4 "$default_cnt" $sizes "$quit"
        [ "$fs_size" = "quit" ] && return

        vmsg 1 "Filesystem size %s Meg" $(nq $fs_size)

        title=$(printf "Please select file system for %s file" $(pqw $file))

        echo
        my_select "$title" fs_type 0 2 ext2 ext3 ext4 "$quit"
        [ "$fs_type" = "quit" ] && return

    fi
    vmsg 1 "Create %s file of type %s and size %s Meg" "$(fq $file)" "$(pq $fs_type)" "$(nq $fs_size)"

    # Now do the actual work
    mount_linuxfs

    mount -o remount,rw $SQFILE_DEV 2>/dev/null

    breakpoint M "Before makefs chroot"

    # Do the mkfs inside a chroot environment
    local chroot_dir=$SQFS_MP
    local tmp_dir=$chroot_dir/tmp/boot
    local tmp_file=/tmp/boot/$SQFILE_PATH/$file

    system_mount $chroot_dir dev tmp etc

    mkdir -p $tmp_dir
    mount --bind /live/boot-dev $tmp_dir

    breakpoint m "before makefs"

    if dd if=/dev/zero of=$full_file bs=1M count=0 seek=$fs_size &>/dev/null; then
        if ! time_cmd chroot $chroot_dir /sbin/mkfs.$fs_type -q -F $tmp_file; then
            err "The %s command failed.  Deleting %s file" $(cqe mkfs.$fs_type) $(pqe $file)
            rm -f $full_file
        fi
    else
        err "The %s command failed.  Deleting %s file" $(cqe dd) $(pqe $file)
        rm -f $full_file
    fi

    system_umount $chroot_dir

    test -e $full_file && msg "Created persistence file %s" $(fq $file)

    eval $needed_var=\$needed

    set_path $LIVE_BIN
    umount $SQFS_MP

    breakpoint m "After makefs umount"
}

default_makefs_size() {
    local avail=$1  size=$3  params
    eval params=\$$2
    eval local $params
    [ "$avail" -lt $mid_size ] && factor=1
    [ "$size" ] || size=$((mid_size + factor * ( avail - mid_size ) / 100))
    [ $size -gt $max_size ] && size=$max_size
    [ $size -gt $avail    ] && size=$avail
    [ $size -lt $min_size ] && return 1
    echo $size
    return 0
}

mount_persist_device() {
    local persist_files=$1  from_persist=$2

    [ "$persist_files" ] || return

    [ "$from_persist" ] || : ${PERSIST_ID:=name=$SQFILE_DEV}

    # Create persistence files if they don't already exist
    [ "$PERSIST_ID" = "name=$SQFILE_DEV" ] && create_persist_files

    heading "Mount persistence device (if needed)"

    ALWAYS_SCAN=$FROM_PERSIST
    FROM_TYPE=${FROM_PERSIST:-usb,hd}

    # FIXME: Does this always work?
    [ "$PERSIST_ID" = "name=$SQFILE_DEV" ] && PERSIST_RETRY=0

    find_files persist "$persist_files" "$PERSIST_MP" "$PERSIST_ID" "$PERSIST_RETRY"
    if [ $? = 0 ]; then

        PERSIST_MP=$FOUND_MP
        PERSIST_DEVICE=$FOUND_DEV
        PERSIST_UUID=$(device_uuid $PERSIST_DEVICE)
        vmsg 7 "       persist_mp: $PERSIST_MP"
        vmsg 7 "   persist_device: $PERSIST_DEVICE"
        vmsg 7 "     persist_uuid: $PERSIST_UUID"
        PERSIST_FULL_PATH="$PERSIST_MP/$PERSIST_PATH"
    else

        if [ "$AUTO_PERSIST" ]; then
            warn "Could not find device with label %s" "$(pqw $AUTO_PERSIST)"
            warn "Disabling persistence"
        else
            warn "Could not find any persistence files"
            #. Could not enable required <type> persistence
            [ "$NEED_ROOTFS" ] && non_fatal "Could not enable required %s persistence" 'root!'
            [ "$NEED_HOMEFS" ] && non_fatal "Could not enable required %s persistence" 'home!'
        fi

        unset WANT_ROOTFS WANT_HOMEFS NEED_ROOTFS NEED_HOMEFS
    fi
}

fsck_persist_dev() {
    local persist_files=$1; shift
    [ "$persist_files" ] || return
    if ! _fsck_persist_dev "$@"; then
        unset WANT_ROOTFS WANT_HOMEFS
    fi
}

_fsck_persist_dev() {
    local dev=$1  mp=$2

    should_fsck $dev persist || return 0
    umount $mp
    do_fsck $dev
    try_mount $dev $mp && return 0

    non_fatal "Could not remount the persistence device"
    return 1
}

mount_and_copy_rootfs() {
    if _mount_and_copy_rootfs "$@"; then
        PERSIST_ROOT=true
        if [ "$STATIC_ROOT" ]; then
            msg "Enabled %s persistence" "$(cq static root)"
        else
            msg "Enabled %s persistence" "$(cq dynamic root)"
        fi
    else

        STATIC_ROOT=
        [ "$NEED_ROOTFS" ] && non_fatal "Could not enable required %s persistence" "$(pqh root!)"
    fi
}

_mount_and_copy_rootfs() {
    mount_persist_file rootfs "$ROOTFS_MP" root "$WANT_ROOTFS" "$NEED_ROOTFS" || return 1
    PERSIST_ROOT_FULL="$PERSIST_FULL_PATH/rootfs"
    check_vid "$SQFS_VID" "$ROOTFS_MP" rootfs                                 || return 1
    [ "$STATIC_ROOT" ] || copy_persist_to_ram                                 || return 1
    return 0
}

#------------------------------------------------------------------------------
# Function: copy_persist_to_ram
#------------------------------------------------------------------------------

copy_persist_to_ram() {

    vmsg 6 "Put persistent root in RAM (from %s)"  "$ROOTFS_MP"

    local persist_used_k=$(du -sk $ROOTFS_MP | awk '{print $1}')
    local persist_used=$((persist_used_k / 1024))
    local format="%s: $num_co%5d ${m_co}M"

    vmsg 7 "$format" '              Persistence uses' $persist_used

    if [ "$persist_used" -ge "$AUFS_RAM_SIZE" ]; then
        vmsg_nc 3 $tbar
        err  "Not enough RAM to hold persistent root"
        warn "You need to %s or use %s persistence" remaster-live "$(cq static root)"
        vmsg_nc 3 $tbar
        return 1
    fi
    vmsg 5 "Copy %s Megabytes to RAM ..." "${num_co}$persist_used${m_co}"
    if ! cp_dir $ROOTFS_MP $AUFS_RAM_MP 2>&1; then
         err "Copy persistent root to RAM failed!  Will erase partial copy ..."
         rm -rf $AUFS_RAM_MP/*
         return 2
     fi
    local ram_used=$(used_space $AUFS_RAM_MP)
    #. AUFS uses [this much RAM]
    vmsg 7 "$format" '                     AUFS uses' $ram_used
    vmsg 7 "$format" '              Persistence uses' $persist_used
    vmsg 6 "${hi_co}%s" "Copy persistent root to RAM succeeded"

    DF_ROOTFS="$(df -P -m $ROOTFS_MP | tail -n 1)"
    log_cmd umount $ROOTFS_MP
    return 0
}

mount_persist_file() {
    local file=$1  mpnt=$2  type=$3  want=$4  need=$5

    [ "$want" ]              || return 1
    [ "$PERSIST_FULL_PATH" ] || return 1

    local full=$(readlink -f $PERSIST_FULL_PATH/$file)
    if ! [ -f "$full" ]; then
        [ "$need" ] && non_fatal "Could not find file %s for required %s persistence" \
            "$(pqh $file)" "$type"
        return 3
    fi

    if should_fsck $full "$type file"; then
        do_fsck $full || return 1
    fi

    heading "mount persistence file %s at %s" "$(fq $file)" "$(fq $mpnt)"

    mkdir -p $mpnt
    if ! try_file_mount $full $mpnt; then
        #. Could not mount file <filename> for <type> persistence
        err "Could not mount file %s for %s persistence" "$full" "$type"
        err "Did not enable %s persistence" "$type"
        return 4
    fi

    PERSISTENCE=$PERSISTENCE,$type
    PERSISTENCE=${PERSISTENCE#,}
    return 0
}

#------------------------------------------------------------------------------
# Function: remaster_rootfs <mountpoint> <full_path>
#
# If we did a remaster or rollback on linuxfs then we perform a similar
# operation on the rootfs file if it exists.
#------------------------------------------------------------------------------
remaster_rootfs() {
    local mp=$1  path=$2

    if [ "$DID_REMASTER" -o "$DID_ROLLBACK" ]; then
        if [ "$path" = "$BOOT_MP/$SQFILE_PATH" ]; then
            msg "Will not remaster %s twice" rootfs
            return
        fi
    fi

    if [ "$DID_REMASTER" ]; then
        [ -e "$path/rootfs"  ]    && mv $path/rootfs     $path/rootfs.old
        [ -e "$path/rootfs.new" ] && mv $path/rootfs.new $path/rootfs
    fi

    if [ "$DID_ROLLBACK" ]; then
        [ -e "$path/rootfs"  ]    && mv $path/rootfs     $path/rootfs.bad
        [ -e "$path/rootfs.old" ] && mv $path/rootfs.old $path/rootfs
    fi
}


#------------------------------------------------------------------------------
#  Update bootloader menu if asked and able
#------------------------------------------------------------------------------
update_gfx_menu() {
    local script=$1  param=$2  dir=$3
    msg
    heading 'GFX Boot Menu Update'

    if ! [ -x "$script" ]; then
        err "Could not find script %s" "$script"
        return
    fi

    if ! [ "$REMASTERABLE" ]; then
        if [ "$DB_PLUS" ]; then
            local tdir=$LIVE_DIR/test
            mkdir -p $tdir
            msg "Use $tdir to test $script"
            cp -r $dir/* $tdir
            dir=$tdir
        else
            err "Can't update %s on read-only boot media" "$(pqe gfx boot)"
            return
        fi
    fi

    #msg "in directory %s" "$white$dir"

    env VERBOSE=$VERBOSE NO_COLOR=$NO_COLOR LOW_COLOR=$LOW_COLOR \
        GFX_LOG_FILE=$LOG_DIR/gfxsave.log $script $dir $param

    vmsg_nc 6 $tbar
}

copy_homefs() {
    local pfull_path=$1
    [ -e "$pfull_path/homefs.new" ] || return
    local tmp_dir=$LIVE_DIR/tmp

    _copy_homefs "$pfull_path" $tmp_dir

    # Always try to clean up even if it is not needed
    for dir in $tmp_dir/homefs*; do
        msg "Clean %s" "$dir"
        mountpoint $dir &>/dev/null && log_cmd umount $dir
        [ -d "$dir" ] && rmdir $dir
    done

}

_copy_homefs() {
    local persist_full_path=$1  tmp_dir=$2

    local homefs_new=$persist_full_path/homefs.new
    local homefs_cur=$persist_full_path/homefs
    local homefs_old=$persist_full_path/homefs.old

    msg "Look for %s" "$homefs_new"
    [ -e "$homefs_new" ] || return

    if ! [ -e "$homefs_cur" ]; then
        msg "No %s file found.  Rename %s to %s" homefs homefs.new homefs
        mv $homefs_new $homefs_cur
        return
    fi

    local rsync=$(which rsync 2>/dev/null)

    if !  [ -x "$rsync" ]; then
        err "Could not find %s program to resize %s" rsync homefs
        return
    fi

    local new_home=$tmp_dir/homefs.new
    local cur_home=$tmp_dir/homefs

    log_cmd mkdir -p $cur_home $new_home

    if ! log_cmd mount -o loop $homefs_cur $cur_home; then
        err "Could not mount %s for copy" homefs
        return
    fi

    if ! log_cmd mount -o loop $homefs_new $new_home; then
        err "Could not mount %s for copy" homefs.new
        return
    fi

    local need_meg=$(used_space $cur_home)
    local have_meg=$(all_space $new_home)
    need_meg=$((need_meg + 10))
    vmsg 6 "Have %s Megabytes free.  Need %s" "$num_co $have_meg$m_co" "$num_co$need_meg$m_co"
    if [ "$need_meg" -gt "$have_meg" ]; then
        err "Not enough room to copy home filesystem"
        return
    fi

    vmsg 6 "Copy home filesystem with the %s program.  Please be patient ..." "$rsync"

    if ! $rsync -aq --delete $cur_home/ $new_home/; then
        err "The %s program failed.  Will not resize %s" rsync homefs
        return
    fi

    log_cmd umount $cur_home
    log_cmd umount $new_home

    log_cmd mv -f $homefs_cur $homefs_old
    log_cmd mv -f $homefs_new $homefs_cur
}

auto_login() {
    local dir file full prog=$1  terms=$2 root=$3
    [ -n "$prog" -a -n "$terms" ] || return

    for dir in /sbin /bin /usr/sbin /usr/bin /usr/local/bin ; do
        file=$dir/$prog
        full=$root/$file
        [ -e "$full" ] || continue
        db_msg "Enable autologin"
        sed -i "s=^\([$terms]\)\(:[0-9]\+:respawn:\).*=\1\2$file tty\1 login -f root=" $root/etc/inittab
        break
    done
}

fancy_prompt() {
    local prompt=$1  dir=$2
    local bashrc=$dir/etc/skel/.bashrc  fp_prog=/usr/local/bin/fancy-prompts.bash

    local cmd=${prompt%%\ *}
    [ -r $dir/$fp_prog -a -n "$prompt" ] || return

    if grep -q $cmd $bashrc; then
        db_msg "fancy prompts were already enabled"
    else
        db_msg "Enable fancy prompts"
        echo "[ -r $fp_prog ] && source $fp_prog" >> $bashrc
        echo "[ -n \"\$(alias $cmd)\" ] && $prompt" >> $bashrc
    fi

    local file full_file
    for file in .bashrc .profile; do
        full_file=$dir/etc/skel/$file
        [ -f "$full_file" ] && cp $full_file $dir/root
    done
}

copy_xtra() {
    local dir xtra_dir=$1/xtra
    [ -d "$xtra_dir" ] || return
    local list=$(ls $xtra_dir)
    [ -n "$list" ] || return

    msgN 'Copy xtra file(s) to:'
    for  dir in $list; do
        [ -d "$xtra_dir/$dir" ] || continue
        msgN " $from_co/$dir"
        cp -a $xtra_dir/$dir $NEW_ROOT/
    done
    msg
}

write_output_files() {
    local dir=$1  out_file=$1/init.out
    mkdir -p $dir
    rm -f $dir/* 2>/dev/null

    [ true ] && cat > $out_file <<Bootstrap_Out
#$tbar
#              file: $out_file
# auto-generated by: $0
#   somewhen around: $(date)
#$tbar
AUFS_MP="$AUFS_MP"
AUFS_RAM_MP="$AUFS_RAM_MP"
AUFS_VID_FILE="$AUFS_MP$VID_FILE"
BOOT_DEV="$SQFILE_DEV"
BOOT_MP="$ORIG_SQFILE_MP"
DF_ROOTFS="$DF_ROOTFS"
DID_REMASTER="$DID_REMASTER"
DID_ROLLBACK="$DID_ROLLBACK"
DID_TORAM="$DID_TORAM"
DISTRO="$DISTRO"
DISTRO_CODENAME="$DISTRO_CODENAME"
DISTRO_VERSION="$DISTRO_VERSION"
FULL_DISTRO="$DISTRO-$DISTRO_VERSION"
LINUXRC_VERSION="$VERSION"
LINUXRC_DATE="$VERSION_DATE"
LIVE_DIR="$FINAL_DIR"
PERSISTENCE="$PERSISTENCE"
PERSIST_DEV="$PERSIST_DEVICE"
PERSIST_UUID="$PERSIST_UUID"
PERSIST_DIR="$PERSIST_FULL_PATH"
PERSIST_FILE="$PERSIST_ROOT_FULL"
PERSIST_MP="$PERSIST_MP"
PERSIST_PATH="$PERSIST_PATH"
REMASTERABLE="$REMASTERABLE"
ROOTFS_MP="$ROOTFS_MP"
RW_MODE="$RW_MODE"
SQFILE_DIR="$ORIG_SQFILE_MP/$SQFILE_PATH"
SQFILE_FULL="$ORIG_SQFILE_MP/$SQFILE_PATH/$SQFILE_NAME"
SQFILE_NAME="$SQFILE_NAME"
SQFILE_PATH="$SQFILE_PATH"
SQFS_MP="$SQFS_MP"
SQFS_VID_FILE="$SQFS_VID_FILE"
STATIC_ROOT="$STATIC_ROOT"
TORAM_MP="$TORAM_MP"
VID_ERROR="$VID_ERROR"
VID_FILE="$VID_FILE"
Bootstrap_Out

    echo "$FINAL_DIR" > $dir/live-dir

    [ "$DID_TORAM"    ]                         && touch $dir/did-toram
    [ "$REMASTERABLE" ]                         && touch $dir/remasterable
    [ -n "$PERSIST_ROOT" -a -z "$STATIC_ROOT" ] && touch $dir/save-persist

    echo "$SQFILE_DEV" > $dir/boot-device
}

old_write_output_files() {
    local dir=$1

    mkdir -p $dir
    [ true ] && cat > $dir/linuxrc.out <<Linuxrc_Out
#$tbar
#              file: $dir/linuxrc.out
# auto-generated by: $0
#   somewhen around: $(date)
#$tbar
AUFS_MP="$AUFS_MP"
AUFS_RAM_MP="$AUFS_RAM_MP"
AUFS_VID_FILE="$AUFS_MP$VID_FILE"
BOOT_DEV="$SQFILE_DEV"
BOOT_MP="$ORIG_SQFILE_MP"
DF_ROOTFS="$DF_ROOTFS"
DID_REMASTER="$DID_REMASTER"
DID_ROLLBACK="$DID_ROLLBACK"
DID_TORAM="$DID_TORAM"
DISTRO="$DISTRO"
DISTRO_CODENAME="$DISTRO_CODENAME"
DISTRO_VERSION="$DISTRO_VERSION"
FULL_DISTRO="$DISTRO-$DISTRO_VERSION"
LINUXRC_VERSION="$VERSION"
LINUXRC_DATE="$VERSION_DATE"
PERSISTENCE="$PERSISTENCE"
PERSIST_DEV="$PERSIST_DEVICE"
PERSIST_DIR="$PERSIST_FULL_PATH"
PERSIST_FILE="$PERSIST_ROOT_FULL"
PERSIST_MP="$PERSIST_MP"
PERSIST_PATH="$PERSIST_PATH"
PERSIST_UUID="$PERSIST_UUID"
REMASTERABLE="$REMASTERABLE"
ROOTFS_MP="$ROOTFS_MP"
RW_MODE="$RW_MODE"
SQFILE_DIR="$ORIG_SQFILE_MP/$SQFILE_PATH"
SQFILE_FULL="$ORIG_SQFILE_MP/$SQFILE_PATH/$SQFILE_NAME"
SQFILE_NAME="$SQFILE_NAME"
SQFILE_PATH="$SQFILE_PATH"
SQFS_MP="$SQFS_MP"
SQFS_VID_FILE="$SQFS_VID_FILE"
STATIC_ROOT="$STATIC_ROOT"
TORAM_MP="$TORAM_MP"
VID_ERROR="$VID_ERROR"
VID_FILE="$VID_FILE"
Linuxrc_Out

    [ "$DID_TORAM" ] && cat > $dir/toram-eject.conf  <<Toram_Out
BOOT_DEV="$SQFILE_DEV"
Toram_Out

    [ "$REMASTERABLE" ] && cat > $dir/remaster-live.conf  <<Remaster_Out
AUFS_MP="$AUFS_MP"
AUFS_RAM_MP="$AUFS_RAM_MP"
AUFS_VID_FILE="$AUFS_MP$VID_FILE"
BOOT_DEV="$SQFILE_DEV"
BOOT_MP="$ORIG_SQFILE_MP"
DID_REMASTER="$DID_REMASTER"
DID_ROLLBACK="$DID_ROLLBACK"
SQFILE_DIR="$ORIG_SQFILE_MP/$SQFILE_PATH"
SQFILE_FULL="$ORIG_SQFILE_MP/$SQFILE_PATH/$SQFILE_NAME"
SQFILE_NAME="$SQFILE_NAME"
SQFILE_PATH="$SQFILE_PATH"
SQFS_MP="$SQFS_MP"
SQFS_VID_FILE="$SQFS_VID_FILE"
VID_FILE="$VID_FILE"
Remaster_Out

    [ -n "$PERSIST_ROOT" -a -z "$STATIC_ROOT" ] && cat > $dir/persist-save.conf <<Persist_Out
AUFS_MP="$AUFS_MP"
AUFS_RAM_MP="$AUFS_RAM_MP"
DF_ROOTFS="$DF_ROOTFS"
PERSIST_DEV="$PERSIST_DEVICE"
PERSIST_UUID="$PERSIST_UUID"
PERSIST_FILE="$PERSIST_ROOT_FULL"
PERSIST_MP="$PERSIST_MP"
ROOTFS_MP="$ROOTFS_MP"
SQFS_MP="$SQFS_MP"
Persist_Out
}

write_log_files() {
    local my_log=$1 final_log=$2 e=$(printf "\e")
    mkdir -p $(dirname $final_log)
    sed -r "s/$e\[[0-9;]+[mK]//g" $my_log > $final_log
    cp  $my_log $final_log.color
}

write_log_files_old() {
    local file=$1 e=$(printf "\e")
    mkdir -p $(dirname $LOG_FILE)
    echo -e "$LOG" | sed -r "s/$e\[[0-9;]+[mK]//g" > $file
    [ "$NO_COLOR" ] || echo -e "$LOG"              > $file.color
}

find_init_prog() {
    local d prog  full_prog prog_var=$1  dir=$2
    eval prog=\$$prog_var
    [ "$prog" ] || return 1

    for d in "" /sbin/ /bin/ /usr/sbin/ /usr/bin/ /usr/local/bin/; do
        [ -e $dir$d$prog ] || continue
        full_prog=$dir$d$prog
        eval $prog_var=\$d\$prog
        break
    done

    if [ -z "$full_prog" ]; then
        err 'Could not find program %s. Will use %s' $prog "/sbin/init"
        return 1
    fi

    if [ ! -x $full_prog ]; then
        err 'Program %s is not executable.  Will use %s'  $d$prog "/sbin/init"
        return 1
    fi
    return 0
}

prepare_switch_root() {
    local new_root=$1  live_dir=$2  final_live=$3

    local new_live=$new_root${final_live:-$live_dir}

    # Now tell kernel where the real modprobe lives
    echo "/sbin/modprobe" > /proc/sys/kernel/modprobe

    # Avoid PID wrap by setting a large max
    echo 4000000 > /proc/sys/kernel/pid_max 2>/dev/null

    mount_tmpfs $new_live 10 $live_dir 755

    #cp /mdev.trace /init $new_live/ 2>/dev/null

    local mp new
    for mp in $live_dir/*; do
        [ $mp = $new_root ] && continue
        mountpoint -q $mp   || continue
        new=$new_live/$(basename $mp)
        mkdir -p $new
        log_cmd mount --move $mp $new

        # ignore error on read-only filesystems
        # I'm not sure why the chmod is needed on the others but it is.
        chmod 755 $new 2>/dev/null
    done

    # Remove libs, modules, and programs we won't need to save a little RAM
    rm -f $(find $live_dir/lib -type f -o -type l | egrep -v "/(ld|libc|libm)[.-][^/]*$")

    (cd $live_dir/bin && rm -rf fbcondecor_helper ntfs-3g gfxsave.sh)
    rm -rf /$live_dir/etc/splash

    # Work around a bug in fbcondecor_helper
    local fbsys=$live_dir/lib/splash/sys
    mountpoint &>/dev/null $fbsys && umount $fbsys

    local dir old new
    for dir in bin config lib locale; do
        old=$live_dir/$dir
        new=$new_live/$dir
        mkdir -p $new
        cp -a $old/* $new
    done

    mkdir -p $new_root/dev
    [ -z "$USE_MDEV" ] && log_cmd mount -t devtmpfs devtmpfs $new_root/dev
    mountpoint -q $new_root/dev || make_nodes $new_root/dev

    umount /dev/pts

    # Create $live_dir/aufs mount in new_root (for historical reasons)
    mkdir -p $new_live/$AUFS_DIR
    mount --bind $new_root $new_live/$AUFS_DIR

    PATH=$new_live/bin:$PATH

    (cd $new_root && mkdir -p sys proc dev/pts)
}

#==============================================================================
# What was last shall be first
main_wrapper "$@"
#==============================================================================
